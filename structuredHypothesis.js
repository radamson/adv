// structuredHypothesis.js

/**
 * Convert a dictionary (object) to a string without certain characters.
 * Removes [ ] { } " and replaces commas with semicolons.
 * @param {Object} d - The object to convert.
 * @returns {string} The formatted string.
 */
export function dictToStr(d) {
    let s = JSON.stringify(d);
    s = s.replace(/[\[\]\{\}\"]/g, ''); // Remove [ ] { } "
    s = s.replace(/,/g, ';');            // Replace commas with semicolons
    return s;
  }
  
  /**
   * Extract messages starting from the last occurrence of a message with name 'user_proxy'.
   * @param {Array} jsonData - Array of message objects.
   * @returns {Array} Array of messages from the last "user_proxy" onward.
   */
  export function extractNodeMessages(jsonData) {
    if (!Array.isArray(jsonData)) return [];
    const userProxyIndices = jsonData.reduce((indices, msg, i) => {
      if (msg.name === "user_proxy") indices.push(i);
      return indices;
    }, []);
    if (userProxyIndices.length === 0) return [];
    const lastUserProxyIndex = userProxyIndices[userProxyIndices.length - 1];
    return jsonData.slice(lastUserProxyIndex);
  }
  
  /**
   * Extract structured hypothesis from node logs by scanning messages for those
   * generated by "hypothesis_generator". Returns an array of objects containing:
   *  - hypothesis: The hypothesis text.
   *  - variables: A string of variables separated by commas.
   *  - relationships: A formatted string of relationships.
   *  - contexts: A string representation of contexts.
   * @param {Array} nodeLogs - Array of message objects (log data).
   * @returns {Array} Extracted hypothesis information.
   */
  export function getStructuredHypothesis(nodeLogs) {
    if (!nodeLogs || nodeLogs.length === 0) return [];
    
    // Find the last occurrence of a message with the name "user_proxy"
    let startIdx = null;
    for (let i = nodeLogs.length - 1; i >= 0; i--) {
      if (nodeLogs[i].name === "user_proxy") {
        startIdx = i;
        break;
      }
    }
    if (startIdx === null) return [];
    
    const nodeMessages = nodeLogs.slice(startIdx);
    let extractedInfo = [];
    let currentHypothesis = null;
    
    for (const msg of nodeMessages) {
      if (msg.name === "hypothesis_generator") {
        try {
          // Parse the content as JSON
          const content = JSON.parse(msg.content);
          const hypothesis = content.hypothesis || "";
          const dimensions = content.dimensions || {};
          const variables = dimensions.variables || [];
          const relationships = dimensions.relationships || [];
          const contexts = dimensions.contexts || [];
    
          // Build a string for relationships
          let relationshipsStr = "";
          relationships.forEach((rel, idx) => {
            relationshipsStr += `Relationship set ${idx}: ${dictToStr(rel)}\n`;
          });
    
          extractedInfo.push({
            hypothesis: hypothesis,
            variables: variables.join(", "),
            relationships: relationshipsStr,
            contexts: dictToStr(contexts),
          });
          // Stop further iterations if a hypothesis is already found
          if (currentHypothesis) break;
        } catch (error) {
          // Ignore errors in JSON parsing
          continue;
        }
      }
    }
    
    return extractedInfo;
  }
  