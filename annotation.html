<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Experiment Tree Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Global styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      font-size: 16px;
      overflow-y: auto;
    }
    details summary {
      font-size: 18px; /* adjust the value as needed */
      font-weight: bold; /* make it bold */
    }
    details {
      margin-bottom: 2em; /* Adjust the value as needed */
    }
    .container {
      display: flex;
      width: 100%;
    }
    /* Panes */
    #left-pane, #details-panel {
      flex: 1;
      width: 50%;
      box-sizing: border-box;
      transition: width 0.3s, display 0.3s;
    }
    #left-pane {
      display: flex;
      flex-direction: column;
      /* Optionally, set a minimum height if desired */
      min-height: 600px;
    }
    /* Let the tree container expand to fill the left pane */
    #tree-container {
      flex: 1;
      width: 100%;
      height: 100%;
    }
    /* Ensure the overall page allows full height usage */
    html, body {
      height: 100%;
      margin: 0;
    }
    /* #left-pane {
      min-height: 800px;
      border: 1px solid #ccc;
      padding: 10px;
    } */
    #details-panel {
      border: 1px solid #ccc;
      padding: 20px;
      white-space: normal;
    }
    /* Pane headers */
    #left-pane-header, #details-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    /* Tree container */
    /* #tree-container {
      flex: 1;
      border: 1px solid #ccc;
      padding: 10px;
      overflow: auto;
      min-height: 400px;
    } */
    /* Buttons */
    button.yes {
      background-color: green;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button.no {
      background-color: red;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button.unsure {
      background-color: orange;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    button.reset {
      background-color: #757575;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 10px 2px;
      cursor: pointer;
    }
    button.fullscreen-toggle {
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    /* Tree nodes and links (horizontal layout) */
    .node circle {
      fill: steelblue;
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .node text {
      font-size: 10px;
    }
    .node.selected circle {
      fill: #ff5722;
    }
    /* Active cluster highlighting */
    .node.active-cluster circle {
      stroke: #FFFF00;
      stroke-width: 4px;
    }
    /* Deactivated nodes */
    .node.deactivated {
      opacity: 0.3;
    }
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }
    /* Cluster number inside node circle */
    .node-cluster-label {
      pointer-events: none;
      font-size: 8px;
      fill: black;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    /* Upload area */
    .upload-area {
      margin-bottom: 20px;
      padding: 10px;
      border: 2px dashed #ccc;
      text-align: center;
    }
    .file-list {
      display: flex;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .file-item {
      background: #f0f0f0;
      padding: 5px 10px;
      margin: 5px;
      border-radius: 3px;
      font-size: 14px;
    }
    h1, h2, h3, h4 {
      color: #333;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
      overflow: auto;
      max-height: 200px;
      border-radius: 4px;
      white-space: pre-wrap;
    }
    /* Top-right counter */
    .annotated-counter {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: #00796b;
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .counter-tab {
      font-size: 14px;
    }
    .duplicate-hypotheses label {
      margin-right: 10px;
    }
    .highlight-yellow {
      background-color: #FFFF00; /* or any highlight color you prefer */
      /* color: white; */
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-green {
      background-color: green; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-orange {
      background-color: orange; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-red {
      background-color: red; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .rubric {
      font-size: 14px;
      font-style: italic;
      margin-top: 0.5em;
      color: #555;
    }
    /* Deduplication Buttons */
    .dup-btn {
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
      color: white;
    }
    .dup-btn[data-answer="Duplicate"] {
      background-color: green;
    }
    .dup-btn[data-answer="Not a duplicate"] {
      background-color: red;
    }
    .dup-btn[data-answer="Unsure"] {
      background-color: orange;
    }
    .dup-reset {
      background-color: grey;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    /* Visual feedback for selected button */
    .dup-btn.selected-dup {
      outline: 2px solid black;
    }
    /* Download button */
    #download-json {
      margin-top: 10px;
      padding: 10px 15px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    /* Relationships table */
    #relationships-table-container {
      overflow-x: auto;
      word-wrap: break-word;
      white-space: normal;
      margin-bottom: 10px;
    }
    #relationships-table {
      border-collapse: collapse;
      width: 100%;
    }
    #relationships-table th, #relationships-table td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
  </style>
</head>
<body>
  <h1>Experiment Tree Visualization</h1>
  
  <!-- Top counter shows ratio of annotated nodes -->
  <div class="annotated-counter" id="annotated-counter">
    <div id="total-nodes" class="counter-tab">Total number of nodes: 0</div>
    <!-- Note: using "annotation-text" here -->
    <div id="annotation-text">Unique nodes annotated: 0 / 0</div>
    <progress id="annotation-progress" value="0" max="0" style="width: 100%; margin-top: 5px;"></progress>
  </div>

  <!-- Upload area -->
  <div class="upload-area" id="upload-area">
    <p>Drop node log files or a clusters file here or click to upload</p>
    <input type="file" id="file-upload" multiple style="display: none">
    <div class="file-list" id="file-list"></div>
  </div>
  
  <div class="container">
    <!-- Left Pane: Tree Pane -->
    <div id="left-pane">
      <div id="left-pane-header">
        <span>Tree Pane</span>
        <button id="left-fullscreen-btn" class="fullscreen-toggle">Full Screen</button>
      </div>
      <div id="tree-container"></div>
    </div>
    <!-- Right Pane: Details Panel -->
    <div id="details-panel">
      <div id="details-panel-header">
        <span>Node Details</span>
        <button id="right-fullscreen-btn" class="fullscreen-toggle">Full Screen</button>
      </div>
      <div id="details-content">
        <p>Click on a node to view details</p>
      </div>
    </div>
  </div>
  
  <div id="action-bar" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
    <button id="download-json" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Hypothesis/Experiment Annotations
    </button>
    <button id="download-all-duplicate-annotations" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Deduplication Annotations
    </button>
    <button id="next-unannotated" style="padding: 10px 15px; background-color: #009688; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Next Unannotated
    </button>
  </div>
  
  <script type="module">
    import { getStructuredHypothesis } from './structuredHypothesis.js';
    
    document.addEventListener("DOMContentLoaded", () => {
      // Global variables
      let beliefData = {};
      let treeData = null;
      let selectedNode = null;
      let allNodesFlat = [];
      let annotatedDedups = [];
      let annotatedNodes = [];
      let answeredClusters = {}; // cluster number -> true if answered
      let clusterMapping = {};   // mapping from node id ("0_0") -> cluster number
      let allowedNodeIDs = new Set();
      
      // File processing with debug logging
      function handleFiles(files) {
        // console.log("Handling files:", files);
        fileList.innerHTML = '';
        let filesProcessed = 0;
        Array.from(files).forEach(file => {
          // console.log("Processing file:", file.name);
          if (/subsample_nodes\.json/.test(file.name)) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const subsampleData = JSON.parse(e.target.result);
                subsampleData.forEach(entry => {
                  const id = entry.node_id.replace("node_", "");  // convert "node_3_0" → "3_0"
                  allowedNodeIDs.add(id);
                });
              } catch (err) {
                console.error("Error parsing subsample_nodes.json:", err);
              }
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          }
          else if (/cluster/i.test(file.name)) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const clustersData = JSON.parse(e.target.result);
                for (const clusterKey in clustersData) {
                  clustersData[clusterKey].forEach(item => {
                    let id = item.node_id;
                    if (id.startsWith("node_")) {
                      id = id.slice(5);
                    }
                    clusterMapping[id] = clusterKey;
                    // console.log(`Mapping node id ${id} to cluster ${clusterKey}`);
                  });
                }
              } catch (err) {
                console.error("Error parsing cluster file:", err);
              }
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          } else if (file.name.match(/belief_(\d+)_(\d+)\.json/)) {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.textContent = file.name;
            fileList.appendChild(fileItem);
            const reader = new FileReader();
            reader.onload = (e) => {
              const content = e.target.result;
              parseBeliefFile(file.name, content);
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          } else {
            filesProcessed++;
            if (filesProcessed === files.length) {
              buildTreeFromBeliefs();
            }
          }
        });
      }
      
      const uploadArea = document.getElementById('upload-area');
      const fileUpload = document.getElementById('file-upload');
      const fileList = document.getElementById('file-list');
      
      uploadArea.addEventListener('click', () => fileUpload.click());
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = '#f0f0f0';
      });
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = 'none';
      });
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = 'none';
        // console.log("Drop event:", e.dataTransfer.files);
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          handleFiles(e.dataTransfer.files);
        }
      });
      
      fileUpload.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFiles(e.target.files);
        }
      });
      
      function parseBeliefFile(filename, content) {
        const match = filename.match(/belief_(\d+)_(\d+)\.json/);
        if (!match) return;
        const level = parseInt(match[1]);
        const index = parseInt(match[2]);
        // console.log(`Parsed belief file for level ${level}, index ${index}`);
        try {
          const data = JSON.parse(content);
          if (!beliefData[level]) {
            beliefData[level] = {};
          }
          beliefData[level][index] = data;
        } catch (e) {
          console.error(`Error parsing ${filename}:`, e);
        }
      }
      
      // Individual reset functions (no longer used)
      function resetExperimentAnnotationForNode(node) {
        node.experimentValid = null;
        // Remove this node's annotation from the global list
        annotatedNodes = annotatedNodes.filter(a => a.node_id !== node.id);
        if (node.cluster !== undefined) {
          delete answeredClusters[node.cluster];
        }
        showNodeDetails(node);
        updateAnnotatedCounter();
        // console.log(`Experiment annotation for node ${node.id} has been reset.`);
      }
      
      function resetContradictionAnnotationForNode(node) {
        node.contradiction = null;
        annotatedNodes = annotatedNodes.filter(a => a.node_id !== node.id);
        if (node.cluster !== undefined) {
          delete answeredClusters[node.cluster];
        }
        showNodeDetails(node);
        updateAnnotatedCounter();
        // console.log(`Hypothesis Validity ${node.id} has been reset.`);
      }
      
      // Global reset function that resets all annotations for a node and updates the progress counter
      function resetAllAnnotationsForNode(node) {
        node.experimentValid = null;
        node.implementationValid = null;
        node.contradiction = null;
        // Optionally reset deduplication annotations as well:
        delete duplicateAnnotationsGlobal[node.id];
        // Remove this node's annotation from the global list
        annotatedNodes = annotatedNodes.filter(a => a.node_id !== node.id);
        if (node.cluster !== undefined) {
          delete answeredClusters[node.cluster];
        }
        // Reset the annotation flags so that the progress counter reflects the change
        node.data.isAnnotated = false;
        node.data.isDedupAnnotated = false;
        showNodeDetails(node);
        updateAnnotatedCounter(); // Update progress counter after reset
        renderTree();
      }
      
      function buildTreeFromBeliefs() {
        const levels = Object.keys(beliefData).map(Number).sort((a, b) => a - b);
        if (levels.length === 0) return;
        // console.log("Building tree from levels:", levels);
        const root = {
          id: "0_0",
          level: 0,
          index: 0,
          data: getNodeDataFromBelief(beliefData[0][0]),
          children: [],
          isAnnotated: false,
          isDedupAnnotated: false,
        };
        let branchingFactor = 0;
        if (beliefData[1]) {
          branchingFactor = Object.keys(beliefData[1]).length;
        }
        function addChildren(node, level) {
          if (!beliefData[level]) return;
          const indices = Object.keys(beliefData[level]).map(Number).sort((a, b) => a - b);
          indices.forEach(idx => {
            const parentIndex = Math.floor(idx / branchingFactor);
            if (node.level === level - 1 && node.index === parentIndex) {
              const childId = `${level}_${idx}`;
              const childNode = {
                id: childId,
                level: level,
                index: idx,
                data: getNodeDataFromBelief(beliefData[level][idx]),
                children: []
              };
              node.children.push(childNode);
              // console.log(`Adding child ${childId} to node ${node.id}`);
              addChildren(childNode, level + 1);
            }
          });
        }
        for (let i = 1; i < levels.length; i++) {
          addChildren(root, i);
        }
        treeData = root;
        allNodesFlat = [];
        flattenNodes(treeData, allNodesFlat);
        // console.log("Tree built:", treeData);
        const greyNodes = allNodesFlat.filter(n => !n.data.review).map(n => n.id);
        console.log("🟦 Grey nodes (no review):", greyNodes);

        assignClusters(treeData);
        renderTree();
        updateAnnotatedCounter();
      }
      
      function assignClusters(node) {
        if (node && node.id) {
          if (clusterMapping[node.id] !== undefined) {
            node.data.cluster = clusterMapping[node.id];
            node.cluster = clusterMapping[node.id];
            // console.log(`Assigned cluster ${node.cluster} to node ${node.id}`);
          } else {
            console.warn(`No matching cluster for node id: ${node.id}`);
          }
        }
        if (node.children) {
          node.children.forEach(child => assignClusters(child));
        }
      }
      
      function getNodeDataFromBelief(beliefArray) {
        if (!beliefArray) return {};
        const priorBeliefs = beliefArray.filter(b => b.distribution === "prior");
        const posteriorBeliefs = beliefArray.filter(b => b.distribution === "posterior");
        const priorBelief = priorBeliefs[0];
        const posteriorBelief = posteriorBeliefs[0];
        if (!posteriorBelief) return {};
        const messages = posteriorBelief.messages || [];
        let experiment = null;
        let hypothesis = posteriorBelief.current_hypothesis || null;
        let analysis = null;
        let review = null;
        let implementation = null;
        messages.forEach(msg => {
          if (msg.name === "user_proxy") {
            experiment = msg.content;
          } else if (msg.name === "experiment_analyst") {
            try {
              analysis = JSON.parse(msg.content).analysis;
            } catch (e) {
              analysis = msg.content;
            }
          } else if (msg.name === "experiment_reviewer") {
            try {
              const reviewData = JSON.parse(msg.content);
              review = reviewData.feedback;
            } catch (e) {
              review = msg.content;
            }
          } else if (msg.name === "experiment_programmer") {
            try {
              const implementationData = JSON.parse(msg.content);
              console.log(implementationData);
              console.log("======================================================================================================================================");
              implementation = implementationData.code;
              console.log(implementation);
            } catch (e) {
              implementation = msg.content;
            }
          }
        });
        const structuredHypothesis = getStructuredHypothesis(messages);
        return {
          hypothesis,
          experiment,
          analysis,
          review,
          implementation,
          priorSupportsHypothesis: priorBelief ? priorBelief.belief_result?.believes_hypothesis : undefined,
          supportsHypothesis: posteriorBelief ? posteriorBelief.belief_result?.believes_hypothesis : undefined,
          structuredHypothesis: structuredHypothesis
        };
      }
      
      function renderTree() {
        if (!treeData) return;
        d3.select("#tree-container").selectAll("*").remove();

        const container = document.getElementById('tree-container');
        const width = container.offsetWidth;
        const nodeCount = countNodes(treeData);
        const height = Math.max(container.offsetHeight, nodeCount * 20);

        const margin = { top: 40, right: 90, bottom: 50, left: 90 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const treeLayout = d3.tree().size([innerHeight, innerWidth]);
        const svg = d3.select("#tree-container")
                      .append("svg")
                      .attr("width", width)
                      .attr("height", height)
                      .append("g")
                      .attr("transform", `translate(${margin.left},${margin.top})`);

        const root = d3.hierarchy(treeData);
        const treeDataLayout = treeLayout(root);

        // Render links
        svg.selectAll(".link")
          .data(treeDataLayout.links())
          .enter()
          .append("path")
          .attr("class", "link")
          .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x));

        // Render nodes
        const node = svg.selectAll(".node")
                        .data(treeDataLayout.descendants())
                        .enter()
                        .append("g")
                        .attr("class", d => {
                          let cls = `node node-${d.data.id}`;
                          const isRoot = d.data.id === "0_0";
                          const isAllowed = allowedNodeIDs.has(d.data.id);
                          if (!isRoot) {
                            if (!isAllowed) {
                              cls += " deactivated";
                            } else if (
                              d.data.cluster !== undefined &&
                              answeredClusters[d.data.cluster] &&
                              d.data.id !== (selectedNode && selectedNode.id) &&
                              !d.data.isAnnotated && !d.data.isDedupAnnotated
                            ) {
                              cls += " deactivated";
                            }
                          }
                          return cls;
                        })
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .on("click", (event, d) => {
                          // When a node is clicked, show its details and update cluster highlights
                          showNodeDetails(d.data);
                          updateClusterHighlights(d.data.cluster);
                        });

        node.append("circle")
            .attr("r", 8)
            .style("fill", d => {
              if (!d.data.data.review) return "#9E9E9E";
              return d.data.data.priorSupportsHypothesis === true ? "#4CAF50" : 
                     d.data.data.priorSupportsHypothesis === false ? "#F44336" : 
                     "#2196F3";
            });

        node.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => d.children ? -12 : 12)
            .attr("text-anchor", d => d.children ? "end" : "start")
            .text(d => `Node_${d.data.level}_${d.data.index}`);

        node.append("text")
            .attr("class", "node-cluster-label")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .text(d => d.data.cluster !== undefined ? d.data.cluster : "N/A");

        node.append("text")
            .attr("x", 0)
            .attr("y", -14)
            .attr("text-anchor", "middle")
            .attr("font-size", "14px")
            .attr("fill", "#2E7D32")
            .text(d => {
              let annotated = annotatedNodes.some(a => a.node_id === d.data.id);
              if (d.data.id === "0_0" && treeData.familiarity) {
                annotated = true;
              }
              d.data.isDedupAnnotated = annotated;
              d.data.isAnnotated = annotated;
              return annotated ? "✔" : "";
            });

        d3.select(".node.node-0_0").classed("deactivated", false).classed("active-cluster", false);
      }
      
      var lastSelectedCluster = null;
      function updateClusterHighlights(selectedCluster) {
        if (lastSelectedCluster && lastSelectedCluster !== selectedCluster) {
          if (!answeredClusters[lastSelectedCluster]) {
            preservedeactivation(lastSelectedCluster, selectedNode.id);
          } else {
            // console.log("PRESERVE DEACTIVATION...")
            preservedeactivation(lastSelectedCluster, selectedNode.id);
          }
        }
        if (!answeredClusters[selectedCluster]) {
          deactivateOtherNodesInCluster(selectedCluster, null);
          d3.selectAll(".node").each(function(d) {
            if (d.data.cluster === selectedCluster && d.data.id === selectedNode.id && d.data.id !== "0_0") {
              d3.select(this)
                .classed("active-cluster", true)
                .classed("deactivated", false);
            }
          });
        }
        d3.selectAll(".node").each(function(d) {
          if (d.data.id !== "0_0" && d.data.cluster !== undefined && d.data.cluster === selectedCluster) {
            if (d.data.id === selectedNode.id) {
              d3.select(this)
                .classed("active-cluster", true)
                .classed("deactivated", false);
            }
          }
        });
        deactivateOtherNodesInCluster(selectedCluster, selectedNode.id);
        lastSelectedCluster = selectedCluster;
      }

      function downloadAllDuplicateAnnotations() {
        if (selectedNode) {
          updateDuplicateAnnotationForCurrentNode(selectedNode);
        }
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(duplicateAnnotationsGlobal, null, 2));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "deduplication_annotations.json");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      }

      function preservedeactivation(cluster, currentNodeId) {
        d3.selectAll(".node").each(function(d) {
          if (d.data.cluster !== undefined && d.data.cluster === cluster) {
            const isAllowed = allowedNodeIDs.has(d.data.id);
            const isSelected = d.data.id === currentNodeId;
            d3.select(this)
              .classed("active-cluster", isSelected)
              .classed("deactivated", !isAllowed); 
          }
        });
      }

      function deactivateOtherNodesInCluster(cluster, currentNodeId) {
        d3.selectAll(".node").each(function(d) {
          if (d.data.cluster === cluster && d.data.id !== currentNodeId) {
            const isAllowed = allowedNodeIDs.has(d.data.id);
            d3.select(this)
              .classed("active-cluster", false)
              .classed("deactivated", !isAllowed);
          }
        });
      }

      function resetClusterNodes(cluster) {
        d3.selectAll(".node").each(function(d) {
          if (d.data.cluster !== undefined && d.data.cluster === cluster) {
            d3.select(this)
              .classed("active-cluster", false)
              .classed("deactivated", false);
          }
        });
      }

      function countNodes(node) {
        if (!node) return 0;
        let count = 1;
        if (node.children) {
          node.children.forEach(child => {
            count += countNodes(child);
          });
        }
        return count;
      }

      function flattenNodes(node, list) {
        if (node.id !== "0_0") list.push(node);  // Skip node_0_0
        if (node.children) {
          node.children.forEach(child => flattenNodes(child, list));
        }
      }
      
      function getTotalNodes() {
        return countNodes(treeData);
      }
      
      function updateAnnotatedCounter() {
        const totalAllowed = allowedNodeIDs.size;
        const fullyAnnotatedCount = allNodesFlat.filter(node =>
          allowedNodeIDs.has(node.id) &&
          node.data.isAnnotated &&
          node.data.isDedupAnnotated
        ).length;
        const totalNodesElem = document.getElementById("total-nodes");
        const annotationTextElem = document.getElementById("annotation-text");
        totalNodesElem.textContent = `Total allowed nodes: ${totalAllowed}`;
        annotationTextElem.textContent = `Unique nodes annotated: ${fullyAnnotatedCount} / ${totalAllowed}`;
        const progressElem = document.getElementById("annotation-progress");
        progressElem.value = fullyAnnotatedCount;
        progressElem.max = totalAllowed;
        // console.log("Updated progress based on allowedNodeIDs");
      }

      function saveDuplicateSection(currentNode) {
        const duplicateData = {
          currentHypothesis: currentNode.data.hypothesis,
          duplicateHypotheses: []
        };
        const dupItems = document.querySelectorAll(".dup-item");
        dupItems.forEach((item, idx) => {
          const pElem = item.querySelector("p");
          let hypText = pElem ? pElem.innerText : "";
          hypText = hypText.replace(/^\d+\.\s*/, "").replace(/\s*Exact match\s*/i, "").trim();
          const annotation = item.dataset.answer || null;
          let nodeIds = [];
          const ulElem = item.querySelector("ul");
          if (ulElem) {
            nodeIds = Array.from(ulElem.querySelectorAll("li")).map(li => li.innerText.trim());
          }
          duplicateData.duplicateHypotheses.push({
            hypothesis: hypText,
            nodeIds: nodeIds,
            annotation: annotation
          });
        });
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(duplicateData, null, 2));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "duplicate_annotations.json");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      }

      function getUniqueHypothesesFromCluster(cluster, currentNodeId) {
        const hypotheses = allNodesFlat
          .filter(node => node.cluster === cluster && node.id !== currentNodeId && node.data.hypothesis)
          .map(node => node.data.hypothesis);
        return Array.from(new Set(hypotheses));
      }

      function getNodeIdsForHypothesis(cluster, hypothesis, currentNodeId) {
        return allNodesFlat
          .filter(node => node.cluster === cluster && node.id !== currentNodeId && node.data.hypothesis === hypothesis)
          .map(node => node.id);
      }
      
      // Update deduplication annotations only via explicit user actions (not automatically on node visit)
      function updateDuplicateAnnotationForCurrentNode(currentNode) {
        const duplicateData = {
          currentHypothesis: currentNode.data.hypothesis,
          duplicateHypotheses: []
        };
        const dupItems = document.querySelectorAll(".dup-item");
        dupItems.forEach((item, idx) => {
          const pElem = item.querySelector("p");
          let hypText = pElem ? pElem.innerText : "";
          hypText = hypText.replace(/^\d+\.\s*/, "").replace(/\s*Exact match\s*/i, "").trim();
          const annotation = item.dataset.answer || null;
          let nodeIds = [];
          const ulElem = item.querySelector("ul");
          if (ulElem) {
            nodeIds = Array.from(ulElem.querySelectorAll("li")).map(li => li.innerText.trim());
          }
          duplicateData.duplicateHypotheses.push({
            hypothesis: hypText,
            nodeIds: nodeIds,
            annotation: annotation
          });
        });
        
        let allSelected;
        duplicateAnnotationsGlobal[currentNode.id] = duplicateData;
        
        if (duplicateData.duplicateHypotheses.length === 0) {
          console.log("No duplicate hypotheses found for this node.");
          currentNode.data.isDedupAnnotated = true;
          allSelected = true;
          console.log("All selected:", allSelected);
        } else {
          console.log("Duplicate hypotheses found...");
          allSelected = duplicateData.duplicateHypotheses.every(item => item.annotation !== null);
          currentNode.data.isDedupAnnotated = allSelected;
          console.log("All selected:", allSelected);
        }
        console.log(`Node ${currentNode.id} dedup annotation complete:`, allSelected);
        checkIfAnnotated(currentNode, currentNode.data);
      }

      function checkIfAnnotated(node, data) {
        const reviewExists = data.review && data.review.trim().length > 0;
        if (node.experimentValid && (reviewExists ? node.contradiction : true) && node.data.isDedupAnnotated) {
          const annotation = {
            node_id: node.id,
            cluster: node.cluster,
            structured_hypothesis: data.structuredHypothesis,
            experiment: data.experiment,
            analysis: data.analysis,
            review: data.review,
            implementation: data.implementation,
            experiment_validity: node.experimentValid,
            hypothesis_verification: node.contradiction,
            implementation_validity: node.implementationValid,
            human_prior: node.humanPrior,
            annotator_familiarity: node.familiarity || null
          };
          if (!annotatedNodes.some(a => a.node_id === node.id)) {
            annotatedNodes.push(annotation);
            console.log("Annotation added for node:", node.id, annotation);
            if (node.cluster !== undefined) {
              answeredClusters[node.cluster] = true;
              console.log("Cluster", node.cluster, "marked as answered.");
            }
          }
          node.data.isAnnotated = true;
          console.log(`IF ---> Node ${node.data.id}: isAnnotated = ${node.data.isAnnotated}, isDedupAnnotated = ${node.data.isDedupAnnotated}`);
        } else {
          node.data.isAnnotated = false;
          console.log(`ELSE --> Node ${node.data.id}: isAnnotated = ${node.data.isAnnotated}, isDedupAnnotated = ${node.data.isDedupAnnotated}`);
        }
        updateAnnotatedCounter();
        renderTree();
      }

      let duplicateAnnotationsGlobal = {};
      
      function showNodeDetails(nodeData) {
        // Removed automatic update of deduplication data on node switch
        // OLD: if (selectedNode && !selectedNode.data.isAnnotated) { updateDuplicateAnnotationForCurrentNode(selectedNode); }
        
        selectedNode = nodeData;
        d3.selectAll(".node").classed("selected", false);
        d3.select(`.node.node-${nodeData.id}`).classed("selected", true);
        const detailsContent = document.getElementById('details-content');
        const data = nodeData.data;
        let html = "";
        
        if (!nodeData.humanPrior) {
          const priorPrompt = `
            <h3>Human Prior</h3>
            <p><strong>Hypothesis:</strong></p>
            <pre>${data.hypothesis}</pre>
            <p>Before seeing the experiment, do you believe this hypothesis is true?</p>
            <button class="yes" id="prior-true">True</button>
            <button class="no" id="prior-false">False</button>
            <button class="unsure" id="prior-unsure">Unsure</button>
          `;
          detailsContent.innerHTML = priorPrompt;
          document.getElementById("prior-true").onclick = () => {
            nodeData.humanPrior = "True";
            showNodeDetails(nodeData);
          };
          document.getElementById("prior-false").onclick = () => {
            nodeData.humanPrior = "False";
            showNodeDetails(nodeData);
          };
          document.getElementById("prior-unsure").onclick = () => {
            nodeData.humanPrior = "Unsure";
            showNodeDetails(nodeData);
          };
          return;
        }
        
        // Node details header
        html += `<p><strong>Node ID:</strong> ${nodeData.id} | <strong>Cluster:</strong> ${data.cluster !== undefined ? data.cluster : "N/A"}</p>`;
        
        if (data.hypothesis) {
          html += `<h3>Hypothesis</h3><pre>${data.hypothesis}</pre>`;
        }
        
        const duplicateHypotheses = getUniqueHypothesesFromCluster(nodeData.cluster, nodeData.id);
        // NEW: If no duplicates exist, mark deduplication as already completed.
        if (duplicateHypotheses.length === 0) {
          nodeData.data.isDedupAnnotated = true;
          // Optionally, you might want to call checkIfAnnotated(nodeData, data) here
          // to update the progress status immediately.
        }
        
        if (duplicateHypotheses.length > 0) {
          const disableRadios = (nodeData.cluster in answeredClusters) || (!allowedNodeIDs.has(nodeData.id));
          html += `<details open style="margin: 10px 0;">
                    <summary style="color: blue; font-weight: bold;">Evaluate Deduplication Results</summary>
                    <p><i>Are the following hypotheses duplicates of the current hypothesis (see above)?</i></p>
                    <div class="duplicate-hypotheses">`;
          duplicateHypotheses.forEach((hyp, idx) => {
            const matchingNodeIds = getNodeIdsForHypothesis(nodeData.cluster, hyp, nodeData.id);
            html += `<div class="dup-item" style="margin-bottom: 10px;">`;
            html += `<p>${idx + 1}. ${hyp}`;
            if (hyp.trim() === data.hypothesis.trim()) {
              html += ` <span class="highlight-yellow">Exact match</span>`;
            }
            html += `<div class="dup-buttons"> 
                      <button type="button" class="dup-btn" data-answer="Duplicate" ${disableRadios ? "disabled" : ""}>Duplicate</button>
                      <button type="button" class="dup-btn" data-answer="Not a duplicate" ${disableRadios ? "disabled" : ""}>Not a duplicate</button>
                      <button type="button" class="dup-btn" data-answer="Unsure" ${disableRadios ? "disabled" : ""}>Unsure</button>
                      <!--<button type="button" class="dup-reset" ${disableRadios ? "disabled" : ""}>Reset</button>-->
                    </div>`;
            if (matchingNodeIds.length > 0) {
              html += `<details open style="margin-top: 5px;">
                        <summary style="font-weight: bold;">Show Node IDs</summary>
                        <ul>`;
              matchingNodeIds.forEach(id => {
                html += `<li>${id}</li>`;
              });
              html += `  </ul>
                      </details>`;
            }
            html += `</div>`;
          });
          html += `   </div>
                  </details>`;
        }
    
        // Structured Hypothesis Details
        if (data.structuredHypothesis && data.structuredHypothesis.length > 0) {
          const stHypo = data.structuredHypothesis[0];
          html += `<details>
              <summary>Structured Hypothesis Details</summary>
              <h4>Variables</h4>
              <div class="variable-tabs"></div>
              <h4>Relationships</h4>
              <div id="relationships-table-container">
                <table id="relationships-table">
                  <thead>
                    <tr>
                      <th>Explanatory</th>
                      <th>Response</th>
                      <th>Relationship</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
              <h4>Contexts</h4>
              <p>${stHypo.contexts}</p>
            </details>`;
        }
    
        // Experiment Section
        if (data.experiment) {
          html += `<details open>
                    <summary>Experiment</summary>
                    <pre>${data.experiment}</pre>
                  </details>`;
        }
    
        // Analysis Section
        if (data.analysis) {
          html += `<details open>
                    <summary>Analysis</summary>
                    <pre>${data.analysis}</pre>
                  </details>`;
        }
    
        if (nodeData.id === "0_0") {
          const storedFamiliarity = nodeData.familiarity || "";
          html += `
            <div id="familiarity-section" style="margin-bottom: 1.5em;">
              <h3>Annotator Familiarity</h3>
              <p>What is your level of familiarity with this dataset/domain?</p>
              <div class="familiarity-options" style="margin: 0.5em 0;">
                ${[1, 2, 3, 4, 5].map(i => `
                  <label style="margin-right: 1em;">
                    <input type="radio" name="familiarity" value="${i}" ${storedFamiliarity === String(i) ? "checked" : ""}>
                    ${i}
                  </label>
                `).join(" ")}
              </div>
              <p class='rubric'>1 = Not familiar at all, 5 = Very familiar</p>
            </div>
          `;
        }
    
        // Review Section
        if (data.review) {
          html += `<details>
                    <summary>Review</summary>
                    <pre>${data.review}</pre>
                  </details>`;
        }
    
        // Implementation Section
        if (data.implementation) {
          html += `<details>
                    <summary>Implementation</summary>
                    <pre>${data.implementation}</pre>
                  </details>`;
        }
    
        let questionsHtml = "";
        if (data.experiment) {
          let disableExp = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
          const isAllowed = allowedNodeIDs.has(nodeData.id);
          disableExp = disableExp || !isAllowed;
          questionsHtml += `<div id="exp-questions">
            <h3>Experiment Validity</h3>
            <p>Is the experiment valid?</p>
            <p class='rubric'>Evaluate whether the experiment is valid. Consider if it can be implemented with the available data with little or no modification. Also assess whether the experiment plan effectively contributes to confirming the hypothesis.</p>
            <button id="experiment-valid-yes" class="yes" ${disableExp ? "disabled" : ""}>Yes</button>
            <button id="experiment-valid-no" class="no" ${disableExp ? "disabled" : ""}>No</button>
            <button id="experiment-valid-unsure" class="unsure" ${disableExp ? "disabled" : ""}>Unsure</button>
            <!--<button class="reset-experiment reset">Reset</button>-->
            <p id="experiment-valid-answer"></p>
          </div>`;
          const expAnsElem = document.getElementById('experiment-valid-answer');
          if (expAnsElem && nodeData.experimentValid) {
            expAnsElem.textContent = `You selected: ${nodeData.experimentValid}`;
          }
        }
        let disableImpl = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
        const isAllowed2 = allowedNodeIDs.has(nodeData.id);
        disableImpl = disableImpl || !isAllowed2;
        questionsHtml += `<div id="impl-validation-questions">
          <h3>Implementation Validation</h3>
          <p>Was the experiment faithfully implemented?</p>
          <p class='rubric'>Assess whether the experiment was faithfully implemented. The implementation follows the experiment plan without any significant deviations.</p>
          <button id="impl-valid-yes" class="yes" ${disableImpl ? "disabled" : ""}>Yes</button>
          <button id="impl-valid-no" class="no" ${disableImpl ? "disabled" : ""}>No</button>
          <button id="impl-valid-unsure" class="unsure" ${disableImpl ? "disabled" : ""}>Unsure</button>
          <!--<button class="reset-impl reset" ${disableImpl ? "disabled" : ""}>Reset</button>-->
          <p id="impl-valid-answer"></p>
        </div>`;
        if (data.review) {
          let disableContr = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
          const isAllowed3 = allowedNodeIDs.has(nodeData.id);
          disableContr = disableContr || !isAllowed3;
          questionsHtml += `<div id="contradiction-questions">
            <h3>Hypothesis Verification</h3>
            <p>Is the hypothesis true or false?</p>
            <p class='rubric'>Indicate whether you believe the hypothesis is true or false based on the experimental evidence presented in the node. If the experimental evidence appears invalid or inconclusive, you may select 'unsure.'</p>
            <button id="contradiction-yes" class="yes" ${disableContr ? "disabled" : ""}>True</button>
            <button id="contradiction-no" class="no" ${disableContr ? "disabled" : ""}>False</button>
            <button id="contradiction-unsure" class="unsure" ${disableContr ? "disabled" : ""}>Unsure</button>
            <!--<button class="reset-contradiction reset">Reset</button>-->
            <p id="contradiction-answer"></p>
          </div>`;
          const contrAnsElem = document.getElementById('contradiction-answer');
          if (contrAnsElem && nodeData.contradiction) {
            contrAnsElem.textContent = `You selected: ${nodeData.contradiction}`;
          }
        }
        // Add a single Reset All button at the end of the questions section
        questionsHtml += `<div style="margin-top: 20px;">
                            <button id="reset-all" class="reset">Reset All</button>
                          </div>`;
    
        detailsContent.innerHTML = html + questionsHtml;
        
        // Attach event listeners for annotator familiarity (for root node)
        if (nodeData.id === "0_0") {
          const radioButtons = detailsContent.querySelectorAll('input[name="familiarity"]');
          radioButtons.forEach(rb => {
            rb.addEventListener('change', () => {
              nodeData.familiarity = rb.value;
              console.log("📊 Annotator familiarity set to:", nodeData.familiarity);
            });
          });
        }
    
        // Attach event listeners for deduplication answer buttons (only update on button click)
        const dupButtons = detailsContent.querySelectorAll('.dup-btn');
        dupButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const dupItem = btn.closest('.dup-item');
            if (dupItem) {
              dupItem.dataset.answer = btn.getAttribute('data-answer');
              const siblingButtons = dupItem.querySelectorAll('.dup-btn');
              siblingButtons.forEach(b => b.classList.remove('selected-dup'));
              btn.classList.add('selected-dup');
            }
            updateDuplicateAnnotationForCurrentNode(nodeData);
          });
        });
    
        // Attach deduplication reset event listeners (if any exist; these are commented out in the HTML)
        const dupResetButtons = detailsContent.querySelectorAll('.dup-reset');
        dupResetButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const dupItem = btn.closest('.dup-item');
            if (dupItem) {
              delete dupItem.dataset.answer;
              const siblingButtons = dupItem.querySelectorAll('.dup-btn');
              siblingButtons.forEach(b => b.classList.remove('selected-dup'));
            }
            updateDuplicateAnnotationForCurrentNode(nodeData);
          });
        });
        
        // Commented out individual reset button event listeners
        /*
        const resetExpButton = detailsContent.querySelector('.reset-experiment');
        if (resetExpButton) {
          resetExpButton.addEventListener('click', () => {
            resetExperimentAnnotationForNode(nodeData);
          });
        }
        const resetContrButton = detailsContent.querySelector('.reset-contradiction');
        if (resetContrButton) {
          resetContrButton.addEventListener('click', () => {
            resetContradictionAnnotationForNode(nodeData);
          });
        }
        const resetImplButton = detailsContent.querySelector('.reset-impl');
        if (resetImplButton) {
          resetImplButton.addEventListener('click', () => {
            nodeData.implementationValid = null;
            const implAnsElem = detailsContent.querySelector('#impl-valid-answer');
            if (implAnsElem) { implAnsElem.textContent = ""; }
            checkIfAnnotated(nodeData, data);
          });
        }
        */
        
        // Attach event listener for the new Reset All button
        const resetAllButton = detailsContent.querySelector('#reset-all');
        if (resetAllButton) {
          resetAllButton.addEventListener('click', () => {
            resetAllAnnotationsForNode(nodeData);
          });
        }
        
        const expValidYes = document.getElementById('experiment-valid-yes');
        const expValidNo = document.getElementById('experiment-valid-no');
        const expValidUnsure = document.getElementById('experiment-valid-unsure');
        if (expValidYes && expValidNo && expValidUnsure && !expValidYes.disabled) {
          expValidYes.addEventListener('click', () => {
            nodeData.experimentValid = "Yes";
            const expAnsElem = document.getElementById('experiment-valid-answer');
            if (expAnsElem) { expAnsElem.textContent = "You selected: Yes"; }
            checkIfAnnotated(nodeData, data);
          });
          expValidNo.addEventListener('click', () => {
            nodeData.experimentValid = "No";
            const expAnsElem = document.getElementById('experiment-valid-answer');
            if (expAnsElem) { expAnsElem.textContent = "You selected: No"; }
            checkIfAnnotated(nodeData, data);
          });
          expValidUnsure.addEventListener('click', () => {
            nodeData.experimentValid = "Unsure";
            const expAnsElem = document.getElementById('experiment-valid-answer');
            if (expAnsElem) { expAnsElem.textContent = "You selected: Unsure"; }
            checkIfAnnotated(nodeData, data);
          });
        }
        
        const implValidYes = document.getElementById('impl-valid-yes');
        const implValidNo = document.getElementById('impl-valid-no');
        const implValidUnsure = document.getElementById('impl-valid-unsure');
        if (implValidYes && implValidNo && implValidUnsure) {
          implValidYes.addEventListener('click', () => {
            nodeData.implementationValid = "Yes";
            const implAnsElem = document.getElementById('impl-valid-answer');
            if (implAnsElem) { implAnsElem.textContent = "You selected: Yes"; }
            checkIfAnnotated(nodeData, data);
          });
          implValidNo.addEventListener('click', () => {
            nodeData.implementationValid = "No";
            const implAnsElem = document.getElementById('impl-valid-answer');
            if (implAnsElem) { implAnsElem.textContent = "You selected: No"; }
            checkIfAnnotated(nodeData, data);
          });
          implValidUnsure.addEventListener('click', () => {
            nodeData.implementationValid = "Unsure";
            const implAnsElem = document.getElementById('impl-valid-answer');
            if (implAnsElem) { implAnsElem.textContent = "You selected: Unsure"; }
            checkIfAnnotated(nodeData, data);
          });
        }
        const contradictionYes = document.getElementById('contradiction-yes');
        const contradictionNo = document.getElementById('contradiction-no');
        const contradictionUnsure = document.getElementById('contradiction-unsure');
        if (contradictionYes && contradictionNo && contradictionUnsure) {
          contradictionYes.addEventListener('click', () => {
            nodeData.contradiction = "True";
            const contrAnsElem = document.getElementById('contradiction-answer');
            if (contrAnsElem) { contrAnsElem.textContent = "You selected: True"; }
            checkIfAnnotated(nodeData, data);
          });
          contradictionNo.addEventListener('click', () => {
            nodeData.contradiction = "False";
            const contrAnsElem = document.getElementById('contradiction-answer');
            if (contrAnsElem) { contrAnsElem.textContent = "You selected: False"; }
            checkIfAnnotated(nodeData, data);
          });
          contradictionUnsure.addEventListener('click', (event) => {
            event.stopPropagation();
            nodeData.contradiction = "Unsure";
            const contrAnsElem = document.getElementById('contradiction-answer');
            if (contrAnsElem) { contrAnsElem.textContent = "You selected: Unsure"; }
            checkIfAnnotated(nodeData, data);
          });
        }
      }
      
      // Full screen toggle for Left Pane
      const leftFullScreenBtn = document.getElementById('left-fullscreen-btn');
      const leftPane = document.getElementById('left-pane');
      const detailsPanel = document.getElementById('details-panel');
      let leftFullScreen = false;
      leftFullScreenBtn.addEventListener('click', () => {
        if (!leftFullScreen) {
          leftPane.style.width = "100%";
          detailsPanel.style.display = "none";
          leftFullScreenBtn.textContent = "Normal";
          leftFullScreen = true;
          // console.log("Left pane set to full screen.");
        } else {
          leftPane.style.width = "50%";
          detailsPanel.style.display = "block";
          leftFullScreenBtn.textContent = "Full Screen";
          leftFullScreen = false;
          // console.log("Left pane set to normal screen.");
        }
        setTimeout(() => {
          if (treeData) renderTree();
        }, 100);
      });
      
      // Full screen toggle for Right Pane
      const rightFullScreenBtn = document.getElementById('right-fullscreen-btn');
      let rightFullScreen = false;
      rightFullScreenBtn.addEventListener('click', () => {
        if (!rightFullScreen) {
          detailsPanel.style.width = "100%";
          leftPane.style.display = "none";
          rightFullScreenBtn.textContent = "Normal";
          rightFullScreen = true;
          // console.log("Right pane set to full screen.");
        } else {
          detailsPanel.style.width = "50%";
          leftPane.style.display = "block";
          rightFullScreenBtn.textContent = "Full Screen";
          rightFullScreen = false;
          // console.log("Right pane set to normal screen.");
        }
      });
    
      const downloadAllDupBtn = document.getElementById('download-all-duplicate-annotations');
      downloadAllDupBtn.addEventListener('click', () => {
        downloadAllDuplicateAnnotations();
      });
      
      // Download JSON button
      const downloadBtn = document.getElementById('download-json');
      downloadBtn.addEventListener('click', () => {
        if (annotatedNodes.length === 0) {
          alert("No data to download.");
          return;
        }
        let exportData = [...annotatedNodes];
        if (treeData && treeData.id === "0_0" && treeData.familiarity) {
          exportData.unshift({
            node_id: "0_0",
            annotator_familiarity: treeData.familiarity
          });
        }
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "hyp_exp_annotations.json");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
        // console.log("Downloaded JSON.");
      });
    
      const nextButton = document.getElementById('next-unannotated');
      nextButton.addEventListener('click', () => {
        const next = allNodesFlat.find(n =>
          allowedNodeIDs.has(n.id) &&
          n.id !== (selectedNode && selectedNode.id) &&
          !(n.cluster in answeredClusters)
        );
        if (next) {
          showNodeDetails(next);
          updateClusterHighlights(next.cluster);
        } else {
          alert("All allowed nodes have been annotated!");
        }
      });
      
    }); // End DOMContentLoaded
  </script>
</body>
</html>
