<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Experiment Tree Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Global styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      font-size: 16px;
      overflow-y: auto;
    }
    .container {
      display: flex;
      width: 100%;
    }
    /* Panes */
    #left-pane, #details-panel {
      flex: 1;
      width: 50%;
      box-sizing: border-box;
      transition: width 0.3s, display 0.3s;
    }

    #left-pane {
      display: flex;
      flex-direction: column;
      /* Optionally, set a minimum height if desired */
      min-height: 600px;
    }

    /* Let the tree container expand to fill the left pane */
    #tree-container {
      flex: 1;
      width: 100%;
      height: 100%;
    }

    /* Ensure the overall page allows full height usage */
    html, body {
      height: 100%;
      margin: 0;
    }
    /* #left-pane {
      min-height: 800px;
      border: 1px solid #ccc;
      padding: 10px;
    } */
    #details-panel {
      border: 1px solid #ccc;
      padding: 20px;
      white-space: normal;
    }
    /* Pane headers */
    #left-pane-header, #details-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    /* Tree container */
    /* #tree-container {
      flex: 1;
      border: 1px solid #ccc;
      padding: 10px;
      overflow: auto;
      min-height: 400px;
    } */
    /* Buttons */
    button.yes {
      background-color: green;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button.no {
      background-color: red;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button.unsure {
      background-color: orange;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    button.reset {
      background-color: #757575;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 10px 2px;
      cursor: pointer;
    }
    button.fullscreen-toggle {
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    /* Tree nodes and links (horizontal layout) */
    .node circle {
      fill: steelblue;
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .node text {
      font-size: 10px;
    }
    .node.selected circle {
      fill: #ff5722;
    }
    /* Active cluster highlighting */
    .node.active-cluster circle {
      stroke: #FFFF00;
      stroke-width: 4px;
    }
    /* Deactivated nodes */
    .node.deactivated {
      opacity: 0.3;
    }
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }
    /* Cluster number inside node circle */
    .node-cluster-label {
      pointer-events: none;
      font-size: 8px;
      fill: black;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    /* Upload area */
    .upload-area {
      margin-bottom: 20px;
      padding: 10px;
      border: 2px dashed #ccc;
      text-align: center;
    }
    .file-list {
      display: flex;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .file-item {
      background: #f0f0f0;
      padding: 5px 10px;
      margin: 5px;
      border-radius: 3px;
      font-size: 14px;
    }
    h1, h2, h3, h4 {
      color: #333;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
      overflow: auto;
      max-height: 200px;
      border-radius: 4px;
      white-space: pre-wrap;
    }
    /* Top-right counter */
    .annotated-counter {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: #00796b;
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .counter-tab {
      font-size: 14px;
    }
    .duplicate-hypotheses label {
      margin-right: 10px;
    }
    .highlight-yellow {
      background-color: #FFFF00; /* or any highlight color you prefer */
      /* color: white; */
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-green {
      background-color: green; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-orange {
      background-color: orange; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-red {
      background-color: red; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    /* Download button */
    #download-json {
      margin-top: 10px;
      padding: 10px 15px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    /* Relationships table */
    #relationships-table-container {
      overflow-x: auto;
      word-wrap: break-word;
      white-space: normal;
      margin-bottom: 10px;
    }
    #relationships-table {
      border-collapse: collapse;
      width: 100%;
    }
    #relationships-table th, #relationships-table td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
  </style>
</head>
<body>
  <h1>Experiment Tree Visualization</h1>
  
  <!-- Top counter shows ratio of annotated nodes -->
  <div class="annotated-counter" id="annotated-counter">
    <div id="total-nodes" class="counter-tab">Total number of nodes: 0</div>
    <!-- Note: using "annotation-text" here -->
    <div id="annotation-text">Unique nodes annotated: 0 / 0</div>
    <progress id="annotation-progress" value="0" max="0" style="width: 100%; margin-top: 5px;"></progress>
  </div>

  <!-- <div class="annotated-counter" id="annotated-counter">
    <div id="total-nodes" class="counter-tab">Total number of nodes: 0</div>
    <div id="annotation-text">Unique nodes annotated: 0 / 0</div>
    New deduplication tracker -->
    <!-- <div id="dedup-annotation-text" class="counter-tab">Deduplication annotations: 0 / 0</div>
    <progress id="annotation-progress" value="0" max="0" style="width: 100%; margin-top: 5px;"></progress>
  </div> -->

  <!-- Upload area -->
  <div class="upload-area" id="upload-area">
    <p>Drop node log files or a clusters file here or click to upload</p>
    <input type="file" id="file-upload" multiple style="display: none">
    <div class="file-list" id="file-list"></div>
  </div>
  
  <div class="container">
    <!-- Left Pane: Tree Pane -->
    <div id="left-pane">
      <div id="left-pane-header">
        <span>Tree Pane</span>
        <button id="left-fullscreen-btn" class="fullscreen-toggle">Full Screen</button>
      </div>
      <div id="tree-container"></div>
    </div>
    <!-- Right Pane: Details Panel -->
    <div id="details-panel">
      <div id="details-panel-header">
        <span>Node Details</span>
        <button id="right-fullscreen-btn" class="fullscreen-toggle">Full Screen</button>
      </div>
      <div id="details-content">
        <p>Click on a node to view details</p>
      </div>
    </div>
  </div>
  
  <!-- Download button -->
  <!-- <div id="action-bar" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
    <button id="download-json" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Hypothesis and Experiment Annotations
    </button>
    <button id="next-unannotated" style="padding: 10px 15px; background-color: #009688; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Next Unannotated
    </button>
  </div> -->

  <div id="action-bar" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
    <button id="download-json" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Hypothesis/Experiment Annotations
    </button>
    <button id="download-all-duplicate-annotations" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Deduplication Annotations
    </button>
    <button id="next-unannotated" style="padding: 10px 15px; background-color: #009688; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Next Unannotated
    </button>
  </div>
  
  
  <script type="module">
    import { getStructuredHypothesis } from './structuredHypothesis.js';
    
    document.addEventListener("DOMContentLoaded", () => {
      // Global variables
      let beliefData = {};
      let treeData = null;
      let selectedNode = null;
      let allNodesFlat = [];
      let annotatedDedups = [];
      let annotatedNodes = [];
      let answeredClusters = {}; // cluster number -> true if answered
      let clusterMapping = {};   // mapping from node id ("0_0") -> cluster number
      let allowedNodeIDs = new Set();
      
      // File processing with debug logging
      function handleFiles(files) {
        // console.log("Handling files:", files);
        fileList.innerHTML = '';
        let filesProcessed = 0;
        Array.from(files).forEach(file => {
          // console.log("Processing file:", file.name);
          if (/subsample_nodes\.json/.test(file.name)) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const subsampleData = JSON.parse(e.target.result);
                subsampleData.forEach(entry => {
                  const id = entry.node_id.replace("node_", "");  // convert "node_3_0" → "3_0"
                  allowedNodeIDs.add(id);
                });
              } catch (err) {
                console.error("Error parsing subsample_nodes.json:", err);
              }
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          }
          else if (/cluster/i.test(file.name)) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const clustersData = JSON.parse(e.target.result);
                for (const clusterKey in clustersData) {
                  clustersData[clusterKey].forEach(item => {
                    let id = item.node_id;
                    if (id.startsWith("node_")) {
                      id = id.slice(5);
                    }
                    clusterMapping[id] = clusterKey;
                    // console.log(`Mapping node id ${id} to cluster ${clusterKey}`);
                  });
                }
              } catch (err) {
                console.error("Error parsing cluster file:", err);
              }
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          } else if (file.name.match(/belief_(\d+)_(\d+)\.json/)) {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.textContent = file.name;
            fileList.appendChild(fileItem);
            const reader = new FileReader();
            reader.onload = (e) => {
              const content = e.target.result;
              parseBeliefFile(file.name, content);
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          } else {
            filesProcessed++;
            if (filesProcessed === files.length) {
              buildTreeFromBeliefs();
            }
          }
        });
      }
      
      const uploadArea = document.getElementById('upload-area');
      const fileUpload = document.getElementById('file-upload');
      const fileList = document.getElementById('file-list');
      
      uploadArea.addEventListener('click', () => fileUpload.click());
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = '#f0f0f0';
      });
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = 'none';
      });
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = 'none';
        // console.log("Drop event:", e.dataTransfer.files);
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          handleFiles(e.dataTransfer.files);
        }
      });
      
      fileUpload.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFiles(e.target.files);
        }
      });
      
      function parseBeliefFile(filename, content) {
        const match = filename.match(/belief_(\d+)_(\d+)\.json/);
        if (!match) return;
        const level = parseInt(match[1]);
        const index = parseInt(match[2]);
        // console.log(`Parsed belief file for level ${level}, index ${index}`);
        try {
          const data = JSON.parse(content);
          if (!beliefData[level]) {
            beliefData[level] = {};
          }
          beliefData[level][index] = data;
        } catch (e) {
          console.error(`Error parsing ${filename}:`, e);
        }
      }
      
      // Instead of one global reset for the node, we define two functions:
      function resetExperimentAnnotationForNode(node) {
        node.experimentValid = null;
        // Remove this node's annotation from the global list
        annotatedNodes = annotatedNodes.filter(a => a.node_id !== node.id);
        if (node.cluster !== undefined) {
          delete answeredClusters[node.cluster];
        }
        showNodeDetails(node);
        updateAnnotatedCounter();
        // console.log(`Experiment annotation for node ${node.id} has been reset.`);
      }
      
      function resetContradictionAnnotationForNode(node) {
        node.contradiction = null;
        annotatedNodes = annotatedNodes.filter(a => a.node_id !== node.id);
        if (node.cluster !== undefined) {
          delete answeredClusters[node.cluster];
        }
        showNodeDetails(node);
        updateAnnotatedCounter();
        // console.log(`Hypothesis Validity ${node.id} has been reset.`);
      }
      
      function buildTreeFromBeliefs() {
        const levels = Object.keys(beliefData).map(Number).sort((a, b) => a - b);
        if (levels.length === 0) return;
        // console.log("Building tree from levels:", levels);
        const root = {
          id: "0_0",
          level: 0,
          index: 0,
          data: getNodeDataFromBelief(beliefData[0][0]),
          children: [],
          isAnnotated: false,
          isDedupAnnotated: false,
        };
        let branchingFactor = 0;
        if (beliefData[1]) {
          branchingFactor = Object.keys(beliefData[1]).length;
        }
        function addChildren(node, level) {
          if (!beliefData[level]) return;
          const indices = Object.keys(beliefData[level]).map(Number).sort((a, b) => a - b);
          indices.forEach(idx => {
            const parentIndex = Math.floor(idx / branchingFactor);
            if (node.level === level - 1 && node.index === parentIndex) {
              const childId = `${level}_${idx}`;
              const childNode = {
                id: childId,
                level: level,
                index: idx,
                data: getNodeDataFromBelief(beliefData[level][idx]),
                children: []
              };
              node.children.push(childNode);
              // console.log(`Adding child ${childId} to node ${node.id}`);
              addChildren(childNode, level + 1);
            }
          });
        }
        for (let i = 1; i < levels.length; i++) {
          addChildren(root, i);
        }
        treeData = root;
        allNodesFlat = [];
        flattenNodes(treeData, allNodesFlat);
        // console.log("Tree built:", treeData);
        const greyNodes = allNodesFlat.filter(n => !n.data.review).map(n => n.id);
        console.log("🟦 Grey nodes (no review):", greyNodes);

        assignClusters(treeData);
        renderTree();
        updateAnnotatedCounter();
      }
      
      function assignClusters(node) {
        if (node && node.id) {
          if (clusterMapping[node.id] !== undefined) {
            node.data.cluster = clusterMapping[node.id];
            node.cluster = clusterMapping[node.id];
            // console.log(`Assigned cluster ${node.cluster} to node ${node.id}`);
          } else {
            console.warn(`No matching cluster for node id: ${node.id}`);
          }
        }
        if (node.children) {
          node.children.forEach(child => assignClusters(child));
        }
      }
      
      function getNodeDataFromBelief(beliefArray) {
        if (!beliefArray) return {};
        const priorBeliefs = beliefArray.filter(b => b.distribution === "prior");
        const posteriorBeliefs = beliefArray.filter(b => b.distribution === "posterior");
        const priorBelief = priorBeliefs[0];
        const posteriorBelief = posteriorBeliefs[0];
        if (!posteriorBelief) return {};
        const messages = posteriorBelief.messages || [];
        let experiment = null;
        let hypothesis = posteriorBelief.current_hypothesis || null;
        let analysis = null;
        let review = null;
        messages.forEach(msg => {
          if (msg.name === "user_proxy") {
            experiment = msg.content;
          } else if (msg.name === "experiment_analyst") {
            try {
              analysis = JSON.parse(msg.content).analysis;
            } catch (e) {
              analysis = msg.content;
            }
          } else if (msg.name === "experiment_reviewer") {
            try {
              const reviewData = JSON.parse(msg.content);
              review = reviewData.feedback;
            } catch (e) {
              review = msg.content;
            }
          }
        });
        const structuredHypothesis = getStructuredHypothesis(messages);
        return {
          hypothesis,
          experiment,
          analysis,
          review,
          priorSupportsHypothesis: priorBelief ? priorBelief.belief_result?.believes_hypothesis : undefined,
          supportsHypothesis: posteriorBelief ? posteriorBelief.belief_result?.believes_hypothesis : undefined,
          structuredHypothesis: structuredHypothesis
        };
      }
      function renderTree() {
        if (!treeData) return;
        d3.select("#tree-container").selectAll("*").remove();

        const container = document.getElementById('tree-container');
        const width = container.offsetWidth;
        const nodeCount = countNodes(treeData);
        const height = Math.max(container.offsetHeight, nodeCount * 20);


        const margin = { top: 40, right: 90, bottom: 50, left: 90 };

        // Calculate inner dimensions based on the container's size
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const treeLayout = d3.tree().size([innerHeight, innerWidth]);
        const svg = d3.select("#tree-container")
                      .append("svg")
                      .attr("width", width)
                      .attr("height", height)
                      .append("g")
                      .attr("transform", `translate(${margin.left},${margin.top})`);

        const root = d3.hierarchy(treeData);
        const treeDataLayout = treeLayout(root);

        // Render links
        svg.selectAll(".link")
          .data(treeDataLayout.links())
          .enter()
          .append("path")
          .attr("class", "link")
          .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x));

        // Render nodes
        const node = svg.selectAll(".node")
                        .data(treeDataLayout.descendants())
                        .enter()
                        .append("g")
                        .attr("class", d => {
                          let cls = `node node-${d.data.id}`;
                          const isAllowed = allowedNodeIDs.has(d.data.id);
                          if (!isAllowed) {
                            cls += " deactivated";
                          } else if (d.data.cluster !== undefined &&
                              answeredClusters[d.data.cluster] &&
                              d.data.id !== (selectedNode && selectedNode.id) &&
                              !d.data.isAnnotated && !d.data.isDedupAnnotated) {
                            cls += " deactivated";
                          }
                          return cls;
                        })
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .on("click", (event, d) => {
                          // console.log("Node clicked:", d.data.id, "Cluster:", d.data.cluster);
                          showNodeDetails(d.data);
                          updateClusterHighlights(d.data.cluster);
                        });

        // Example for rendering the node shapes and labels...
        node.append("circle")
            .attr("r", 8)
            .style("fill", d => {
              if (!d.data.data.review) return "#9E9E9E";
              return d.data.data.priorSupportsHypothesis === true ? "#4CAF50" : 
                    d.data.data.priorSupportsHypothesis === false ? "#F44336" : 
                    "#2196F3";
            });

        node.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => d.children ? -12 : 12)
            .attr("text-anchor", d => d.children ? "end" : "start")
            .text(d => `Node_${d.data.level}_${d.data.index}`);

        // Cluster number inside the node
        node.append("text")
            .attr("class", "node-cluster-label")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .text(d => d.data.cluster !== undefined ? d.data.cluster : "N/A");

        node.append("text")
            .attr("x", 0)
            .attr("y", -14)  // positioned above the node
            .attr("text-anchor", "middle")
            .attr("font-size", "14px")
            .attr("fill", "#2E7D32") // green
            .text(d => {
              const annotated = annotatedNodes.some(a => a.node_id === d.data.id);
              d.data.isDedupAnnotated = annotated;
              d.data.isAnnotated = annotated;
              console.log(`Node ${d.data.id}: isAnnotated = ${d.data.isAnnotated}, isDedupAnnotated = ${d.data.isDedupAnnotated}`);
              return annotated ? "✔" : "";
            });
        // node.append("text")
        //     .attr("x", 0)
        //     .attr("y", -14)  // positioned above the node
        //     .attr("text-anchor", "middle")
        //     .attr("font-size", "14px")
        //     .attr("fill", "#2E7D32") // green
        //     .text(d => {
        //       // Show a tick only if the node is annotated AND deduplication annotations are complete.
        //       // console.log(`Node ${d.data.id}: isAnnotated = ${d.data.isAnnotated}, isDedupAnnotated = ${d.data.isDedupAnnotated}`);
        //       return (d.data.isAnnotated && d.data.isDedupAnnotated) ? "✔" : "";
        //     });

      }      
      
        var lastSelectedCluster = null;
        // var answeredClusters = {}; // This should be defined as appropriate elsewhere in your code
        // var selectedNode = {};     // This should contain the current selected node's data
        function updateClusterHighlights(selectedCluster) {
          // If we switched clusters, reset the nodes in the previous cluster only if it is not annotated.
          // console.log("Selected node = ", selectedNode.id)
          // console.log("Selected cluster = ", selectedCluster, "Last selected cluster = ", lastSelectedCluster)
          // console.log("Answered clusters = ", answeredClusters);
          // console.log("---------------------------------------------------------------------------------------")
          if (lastSelectedCluster && lastSelectedCluster !== selectedCluster) {
            if (!answeredClusters[lastSelectedCluster]) {
              resetClusterNodes(lastSelectedCluster);
            } else{
              // console.log("PRESERVE DEACTIVATION...")
              preservedeactivation(lastSelectedCluster, selectedNode.id);
            }

          }

          // For the newly selected cluster, reset nodes only if it is not annotated.
          if (!answeredClusters[selectedCluster]) {
            resetClusterNodes(selectedCluster);
          }

          // Activate the selected node in the current cluster.
          d3.selectAll(".node").each(function(d) {
            if (d.data.cluster !== undefined && d.data.cluster === selectedCluster) {
              if (d.data.id === selectedNode.id) {
                d3.select(this)
                  .classed("active-cluster", true)
                  .classed("deactivated", false);
              }
            }
          });

          // Deactivate all other nodes in the current cluster.
          deactivateOtherNodesInCluster(selectedCluster, selectedNode.id);

          // Update the global state with the current cluster.
          lastSelectedCluster = selectedCluster;
        }

        function downloadAllDuplicateAnnotations() {
          // Optionally, update the annotation for the currently visible node before downloading.
          if (selectedNode) {
            updateDuplicateAnnotationForCurrentNode(selectedNode);
          }
          const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(duplicateAnnotationsGlobal, null, 2));
          const downloadAnchor = document.createElement("a");
          downloadAnchor.setAttribute("href", dataStr);
          downloadAnchor.setAttribute("download", "deduplication_annotations.json");
          document.body.appendChild(downloadAnchor);
          downloadAnchor.click();
          downloadAnchor.remove();
        }

        // Helper function 1: Deactivate all nodes in the same cluster except the current node
        function preservedeactivation(cluster, currentNodeId) {
          d3.selectAll(".node").each(function(d) {
            // console.log("Checking node:", d.data.id, "while selected node is:", currentNodeId);
            // console.log(d)
            if (d.data.cluster !== undefined){
            if (d.data.cluster === cluster && !d.data.isAnnotated) {
              d3.select(this)
                .classed("active-cluster", false)
                .classed("deactivated", true);
            } else if (d.data.cluster === cluster && d.data.isAnnotated) {
              d3.select(this)
                .classed("active-cluster", false)
                .classed("deactivated", false);
            }
          }
          });
        }
        // Helper function 1: Deactivate all nodes in the same cluster except the current node
        function deactivateOtherNodesInCluster(cluster, currentNodeId) {
          d3.selectAll(".node").each(function(d) {
            if (d.data.cluster !== undefined && d.data.cluster === cluster) {
              if (d.data.id !== currentNodeId) {
                d3.select(this)
                  .classed("active-cluster", false)
                  .classed("deactivated", true);
              }
            }
          });
        }

        // Helper function 2: Reset activation and deactivation for all nodes in the specified cluster
        function resetClusterNodes(cluster) {
          d3.selectAll(".node").each(function(d) {
            if (d.data.cluster !== undefined && d.data.cluster === cluster) {
              d3.select(this)
                .classed("active-cluster", false)
                .classed("deactivated", false);
            }
          });
        }


      
      function countNodes(node) {
        if (!node) return 0;
        let count = 1;
        if (node.children) {
          node.children.forEach(child => {
            count += countNodes(child);
          });
        }
        return count;
      }

      function flattenNodes(node, list) {
        if (node.id !== "0_0") list.push(node);  // Skip node_0_0
        if (node.children) {
          node.children.forEach(child => flattenNodes(child, list));
        }
      }
      
      function getTotalNodes() {
        return countNodes(treeData);
      }
      
      // // Updated annotated counter function using the correct element id and updating the progress bar.
      // function updateAnnotatedCounter() {
      //   const total = getTotalNodes();
      //   const uniqueClusters = new Set();
      //   function collectClusters(node) {
      //     if (node && node.data.cluster !== undefined) {
      //       uniqueClusters.add(node.data.cluster);
      //     }
      //     if (node.children) {
      //       node.children.forEach(child => collectClusters(child));
      //     }
      //   }
      //   collectClusters(treeData);
      //   const totalNodesElem = document.getElementById("total-nodes");
      //   const annotationTextElem = document.getElementById("annotation-text");
      //   totalNodesElem.textContent = `Total number of nodes: ${total}`;
      //   const answeredCount = Object.keys(answeredClusters).length;
      //   annotationTextElem.textContent = `Unique nodes annotated: ${answeredCount} / ${uniqueClusters.size}`;
      //   const progressElem = document.getElementById("annotation-progress");
      //   progressElem.value = answeredCount;
      //   progressElem.max = uniqueClusters.size;
      //   console.log("Annotated counter updated:", totalNodesElem.textContent, annotationTextElem.textContent);
      // }
      function updateAnnotatedCounter() {
        const total = getTotalNodes();
        const uniqueClusters = new Set();
        function collectClusters(node) {
          if (node && node.data.cluster !== undefined) {
            uniqueClusters.add(node.data.cluster);
          }
          if (node.children) {
            node.children.forEach(child => collectClusters(child));
          }
        }
        collectClusters(treeData);

        // Count only nodes that are fully annotated.
        const fullyAnnotatedCount = allNodesFlat.filter(node => node.data.isAnnotated && node.data.isDedupAnnotated).length;
        
        const totalNodesElem = document.getElementById("total-nodes");
        const annotationTextElem = document.getElementById("annotation-text");
        totalNodesElem.textContent = `Total number of nodes: ${total}`;
        annotationTextElem.textContent = `Unique nodes annotated: ${fullyAnnotatedCount} / ${uniqueClusters.size}`;
        const progressElem = document.getElementById("annotation-progress");
        progressElem.value = fullyAnnotatedCount;
        progressElem.max = uniqueClusters.size;
        // console.log("Annotated counter updated:", totalNodesElem.textContent, annotationTextElem.textContent);
      }
      
      // function checkIfAnnotated(node, data) {
      //   const reviewExists = data.review && data.review.trim().length > 0;
      //   // Node is only annotated if experimentValid is set and, if review exists, contradiction is also set.
      //   if (node.experimentValid && (reviewExists ? node.contradiction : true)) {
      //     // const surprisal_gt = data.priorSupportsHypothesis !== data.supportsHypothesis;
      //     const annotation = {
      //       node_id: node.id,
      //       cluster: node.cluster,
      //       structured_hypothesis: data.structuredHypothesis,
      //       experiment: data.experiment,
      //       analysis: data.analysis,
      //       review: data.review,
      //       experiment_validity: node.experimentValid,
      //       // surprisal_gt: surprisal_gt
      //       hypothesis_verification: node.contradiction
      //     };
      //     if (!annotatedNodes.some(a => a.node_id === node.id)) {
      //       annotatedNodes.push(annotation);
      //       console.log("Annotation added for node:", node.id, annotation);
      //       if (node.cluster !== undefined) {
      //         answeredClusters[node.cluster] = true;
      //         console.log("Cluster", node.cluster, "marked as answered.");
      //       }
      //     }
      //   }
      //   updateAnnotatedCounter();
      //   renderTree();
      // }
      
      function saveDuplicateSection(currentNode) {
          const duplicateData = {
            currentHypothesis: currentNode.data.hypothesis,
            duplicateHypotheses: []
          };

          // Find all duplicate hypothesis items.
          const dupItems = document.querySelectorAll(".dup-item");
          dupItems.forEach((item, idx) => {
          // Get the hypothesis text from the <p> element and remove the numbering and "Exact match" label.
          const pElem = item.querySelector("p");
          let hypText = pElem ? pElem.innerText : "";
          hypText = hypText.replace(/^\d+\.\s*/, "").replace(/\s*Exact match\s*/i, "").trim();

          // Get the selected annotation (radio button) for this hypothesis.
          const selectedRadio = item.querySelector(`input[name="dup-hyp-${idx}"]:checked`);
          const annotation = selectedRadio ? selectedRadio.value : null;

          // Get the list of node IDs from the <ul> element.
          let nodeIds = [];
          const ulElem = item.querySelector("ul");
          if (ulElem) {
            nodeIds = Array.from(ulElem.querySelectorAll("li")).map(li => li.innerText.trim());
          }

          duplicateData.duplicateHypotheses.push({
            hypothesis: hypText,
            nodeIds: nodeIds,
            annotation: annotation
          });
        });

        // Create and trigger a download for the JSON file.
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(duplicateData, null, 2));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "duplicate_annotations.json");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      }

      function getUniqueHypothesesFromCluster(cluster, currentNodeId) {
        // Filter nodes from the flattened list that are in the same cluster,
        // exclude the current node, and ensure a hypothesis exists.
        const hypotheses = allNodesFlat
          .filter(node => node.cluster === cluster && node.id !== currentNodeId && node.data.hypothesis)
          .map(node => node.data.hypothesis);
          
        // Return only unique hypotheses
        return Array.from(new Set(hypotheses));
      }

      function getNodeIdsForHypothesis(cluster, hypothesis, currentNodeId) {
        return allNodesFlat
          .filter(node => node.cluster === cluster && node.id !== currentNodeId && node.data.hypothesis === hypothesis)
          .map(node => node.id);
      }
      
      function updateDuplicateAnnotationForCurrentNode(currentNode) {
        const duplicateData = {
          currentHypothesis: currentNode.data.hypothesis,
          duplicateHypotheses: []
        };

        // Loop over each duplicate hypothesis item.
        const dupItems = document.querySelectorAll(".dup-item");
        dupItems.forEach((item, idx) => {
          const pElem = item.querySelector("p");
          let hypText = pElem ? pElem.innerText : "";
          // Remove numbering and the "Exact match" text.
          hypText = hypText.replace(/^\d+\.\s*/, "").replace(/\s*Exact match\s*/i, "").trim();

          // Get the selected annotation from the radio button.
          const selectedRadio = item.querySelector(`input[name="dup-hyp-${idx}"]:checked`);
          const annotation = selectedRadio ? selectedRadio.value : null;

          // Get the list of node IDs (if any).
          let nodeIds = [];
          const ulElem = item.querySelector("ul");
          if (ulElem) {
            nodeIds = Array.from(ulElem.querySelectorAll("li")).map(li => li.innerText.trim());
          }

          duplicateData.duplicateHypotheses.push({
            hypothesis: hypText,
            nodeIds: nodeIds,
            annotation: annotation
          });
        });
        
        let allSelected;
        // Save/update the global duplicate annotations for this node.
        duplicateAnnotationsGlobal[currentNode.id] = duplicateData;
        
        if (duplicateData.duplicateHypotheses.length === 0) {
          console.log("No duplicate hypotheses found for this node.");
          currentNode.data.isDedupAnnotated = true;
          allSelected = true;
          console.log("All selected:", allSelected);
        } else {
          console.log("Duplicate hypotheses found...");
          // Set the flag to true only if every duplicate hypothesis has a non-null annotation.
          allSelected = duplicateData.duplicateHypotheses.every(item => item.annotation !== null);
          currentNode.data.isDedupAnnotated = allSelected;
          console.log("All selected:", allSelected);
        }

        // Set the new isDedupAnnotated flag:
        // It is true only if every duplicate hypothesis has a non-null annotation.
        // const allSelected = duplicateData.duplicateHypotheses.every(item => item.annotation !== null);
        // console.log("All selected:", allSelected);
      
        // currentNode.data.isDedupAnnotated = allSelected;

        console.log(`Node ${currentNode.id} dedup annotation complete:`, allSelected);

        // After updating dedup data, update the overall annotated status.
        checkIfAnnotated(currentNode, currentNode.data);
      }

      function checkIfAnnotated(node, data) {
        const reviewExists = data.review && data.review.trim().length > 0;
        // Only mark the node as annotated if:
        // 1. Experiment validity is set, and if a review exists, then a contradiction is also set.
        // 2. And also, the deduplication annotations are complete.
        
        if (node.experimentValid && (reviewExists ? node.contradiction : true) && node.data.isDedupAnnotated) {
          const annotation = {
            node_id: node.id,
            cluster: node.cluster,
            structured_hypothesis: data.structuredHypothesis,
            experiment: data.experiment,
            analysis: data.analysis,
            review: data.review,
            experiment_validity: node.experimentValid,
            hypothesis_verification: node.contradiction
          };
          if (!annotatedNodes.some(a => a.node_id === node.id)) {
            annotatedNodes.push(annotation);
            console.log("Annotation added for node:", node.id, annotation);
            if (node.cluster !== undefined) {
              answeredClusters[node.cluster] = true;
              console.log("Cluster", node.cluster, "marked as answered.");
            }
          }
          // Mark the node as fully annotated.
          node.data.isAnnotated = true;
          console.log(`IF ---> Node ${node.data.id}: isAnnotated = ${node.data.isAnnotated}, isDedupAnnotated = ${node.data.isDedupAnnotated}`);
        } else {
          // Optionally, you can clear the flag if conditions are not met.
          node.data.isAnnotated = false;
          console.log(`ELSE --> Node ${node.data.id}: isAnnotated = ${node.data.isAnnotated}, isDedupAnnotated = ${node.data.isDedupAnnotated}`);
        }
        updateAnnotatedCounter();
        
        renderTree();
      }

      // function updateDedupAnnotationCounter() {
      //   let annotatedCount = 0;
      //   let totalNodesWithDupSection = 0;
        
      //   allNodesFlat.forEach(node => {
      //     // Check if node has deduplication data (i.e. a dedup section exists)
      //     const dupH = getUniqueHypothesesFromCluster(node.cluster, node.id);
      //     if (dupH.length > 0) {
      //       totalNodesWithDupSection++;
      //       if (duplicateAnnotationsGlobal[node.id]) {
      //         // Verify that every duplicate hypothesis has an annotation.
      //         const allAnnotated = duplicateAnnotationsGlobal[node.id].duplicateHypotheses.every(item => item.annotation !== null);
      //         if (allAnnotated) {
      //           annotatedCount++;
      //         }
      //       }
      //     }
      //   });
        
      //   const dedupCounterElem = document.getElementById("dedup-annotation-text");
      //   if (dedupCounterElem) {
      //     dedupCounterElem.textContent = `Deduplication annotations: ${annotatedCount} / ${totalNodesWithDupSection}`;
      //   }
      // }

      let duplicateAnnotationsGlobal = {};
      function showNodeDetails(nodeData) {
        if (selectedNode) {
          updateDuplicateAnnotationForCurrentNode(selectedNode);
        }
        selectedNode = nodeData;
        // console.log("Showing details for node:", nodeData.id);
        d3.selectAll(".node").classed("selected", false);
        d3.select(`.node.node-${nodeData.id}`).classed("selected", true);
        const detailsContent = document.getElementById('details-content');
        const data = nodeData.data;
        let html = "";
        // Node details header
        html += `<p><strong>Node ID:</strong> ${nodeData.id} | <strong>Cluster:</strong> ${data.cluster !== undefined ? data.cluster : "N/A"}</p>`;
        // Hypothesis
        // if (data.hypothesis) {
          // html += `<h3>Hypothesis</h3><pre>${data.hypothesis}</pre>`;
        // }
        //Evaluate Deduplication
        // Duplicate Hypotheses Section: Get unique hypotheses from other nodes in the same cluster.
        // const duplicateHypotheses = getUniqueHypothesesFromCluster(nodeData.cluster, nodeData.id);

        // console.log("Duplicate Hypotheses: ",duplicateHypotheses);
        
        // if (data.hypothesis) {
        // // html += `<h3>Hypothesis</h3><pre>${data.hypothesis}</pre>`;
        
        // // Duplicate Hypotheses Section: Get unique hypotheses from other nodes in the same cluster.
        //   const duplicateHypotheses = getUniqueHypothesesFromCluster(nodeData.cluster, nodeData.id);
        
        //   if (duplicateHypotheses.length > 0) {
        //     html += `<details style="margin: 10px 0;">
        //               <summary style="color: blue; font-weight: bold;">Evaluate Deduplication Results</summary>
        //               <p><i>Are the following hypotheses duplicates of the current hypothesis (see above)?</i></p>
        //               <div class="duplicate-hypotheses">`;
        //     duplicateHypotheses.forEach((hyp, idx) => {
        //       // Retrieve node IDs for this hypothesis using the helper function
        //       const matchingNodeIds = getNodeIdsForHypothesis(nodeData.cluster, hyp, nodeData.id);
        //       html += `<div class="dup-item" style="margin-bottom: 10px;">`;
        //       // Number the hypothesis and make it bold
        //       // html += `<p><strong>${idx + 1}. ${hyp}</strong>`;
        //         html += `${idx + 1}. ${hyp}`;
        //       // If the hypothesis exactly matches the current hypothesis, add "Exact match" in green bold.
        //       if (hyp.trim() === data.hypothesis.trim()) {
        //         html += ` <span style="color: green; font-weight: bold;">Exact match</span>`;
        //       }
        //       html += `</p>
        //                 <label style="color: green; font-weight: bold;"><input type="radio" name="dup-hyp-${idx}" value="Duplicate"> Duplicate</label>
        //                 <label style="color: red; font-weight: bold;"><input type="radio" name="dup-hyp-${idx}" value="Not a duplicate"> Not a duplicate</label>
        //                 <label style="color: orange; font-weight: bold;"><input type="radio" name="dup-hyp-${idx}" value="Unsure"> Unsure</label>`;
        //       // Expandable section to show node IDs for this hypothesis
        //       if (matchingNodeIds.length > 0) {
        //         html += `<details style="margin-top: 5px;">
        //                   <summary>Show Node IDs</summary>
        //                   <ul>`;
        //         matchingNodeIds.forEach(id => {
        //           html += `<li>${id}</li>`;
        //         });
        //         html += `  </ul>
        //                 </details>`;
        //       }
        //       html += `</div>`;
        //     });
        //     html += `   </div>
        //             </details>`;
        //   }
        // }
        if (data.hypothesis) {
          html += `<h3>Hypothesis</h3><pre>${data.hypothesis}</pre>`;
        }

        const duplicateHypotheses = getUniqueHypothesesFromCluster(nodeData.cluster, nodeData.id);
        
        if (duplicateHypotheses.length > 0) {
          html += `<details open style="margin: 10px 0;">
                    <summary style="color: blue; font-weight: bold;">Evaluate Deduplication Results</summary>
                    <p><i>Are the following hypotheses duplicates of the current hypothesis (see above)?</i></p>
                    <div class="duplicate-hypotheses">`;
          duplicateHypotheses.forEach((hyp, idx) => {
            // Retrieve node IDs for this hypothesis using the helper function
            const matchingNodeIds = getNodeIdsForHypothesis(nodeData.cluster, hyp, nodeData.id);
            html += `<div class="dup-item" style="margin-bottom: 10px;">`;
            // Number the hypothesis and make it bold
            html += `<p>${idx + 1}. ${hyp}`;
            // If the hypothesis exactly matches the current hypothesis, add "Exact match" in green bold.
            if (hyp.trim() === data.hypothesis.trim()) {
              html += ` <span class="highlight-yellow">Exact match</span>`;
            }
            html += `</p>
                      <div class="duplicate-hypotheses">
                        <label class="highlight-green">
                          <input type="radio" name="dup-hyp-${idx}" value="Duplicate"> Duplicate
                        </label>
                        <label class="highlight-red">
                          <input type="radio" name="dup-hyp-${idx}" value="Not a duplicate"> Not a duplicate
                        </label>
                        <label class="highlight-orange">
                          <input type="radio" name="dup-hyp-${idx}" value="Unsure"> Unsure
                        </label>
                      </div>`;
            // Expandable section to show node IDs for this hypothesis, expanded by default.
            if (matchingNodeIds.length > 0) {
              html += `<details open style="margin-top: 5px;">
                        <summary style="font-weight: bold;">Show Node IDs</summary>
                        <ul>`;
              matchingNodeIds.forEach(id => {
                html += `<li>${id}</li>`;
              });
              html += `  </ul>
                      </details>`;
            }
            html += `</div>`;
          });
          html += `   </div>
                  </details>`;
          // (Optional: You may still include a save button for the current node if desired.)
        }
    
      
        // Structured Hypothesis Details
        if (data.structuredHypothesis && data.structuredHypothesis.length > 0) {
          const stHypo = data.structuredHypothesis[0];
          html += `<h3>Structured Hypothesis Details</h3>`;
          html += `<h4>Variables</h4>
                   <div class="variable-tabs"></div>`;
          html += `<h4>Relationships</h4>
                   <div id="relationships-table-container">
                     <table id="relationships-table">
                       <thead>
                         <tr>
                           <th>Explanatory</th>
                           <th>Response</th>
                           <th>Relationship</th>
                         </tr>
                       </thead>
                       <tbody></tbody>
                     </table>
                   </div>`;
          html += `<h4>Contexts</h4><p>${stHypo.contexts}</p>`;
        }
        // Experiment, Analysis, Review
        if (data.experiment) {
          html += `<h3>Experiment</h3><pre>${data.experiment}</pre>`;
        }
        if (data.analysis) {
          html += `<h3>Analysis</h3><pre>${data.analysis}</pre>`;
        }
        if (data.review) {
          html += `<h3>Review</h3><pre>${data.review}</pre>`;
        }
        // Append questions with separate reset buttons.
        let questionsHtml = "";
        if (data.experiment) {
          let disableExp = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
          const isAllowed = allowedNodeIDs.has(nodeData.id);
          disableExp = disableExp || !isAllowed;
          questionsHtml += `<div id="exp-questions">
            <h3>Experiment Validity</h3>
            <p>Is the experiment valid?</p>
            <button id="experiment-valid-yes" class="yes" ${disableExp ? "disabled" : ""}>Yes</button>
            <button id="experiment-valid-no" class="no" ${disableExp ? "disabled" : ""}>No</button>
            <button id="experiment-valid-unsure" class="unsure" ${disableExp ? "disabled" : ""}>Unsure</button>
            <button class="reset-experiment reset">Reset</button>
            <p id="experiment-valid-answer"></p>
          </div>`;
          if (nodeData.experimentValid) {
            document.getElementById('experiment-valid-answer').textContent = `You selected: ${nodeData.experimentValid}`;
          }
        }
        if (data.review) {
          let disableContr = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
          const isAllowed = allowedNodeIDs.has(nodeData.id);
          disableContr = disableContr || !isAllowed;
          questionsHtml += `<div id="contradiction-questions">
            <h3>Hypothesis Verification</h3>
            <p>Is the hypothesis true or false?</p>
            <button id="contradiction-yes" class="yes" ${disableContr ? "disabled" : ""}>True</button>
            <button id="contradiction-no" class="no" ${disableContr ? "disabled" : ""}>False</button>
            <button id="contradiction-unsure" class="unsure" ${disableContr ? "disabled" : ""}>Unsure</button>
            <button class="reset-contradiction reset">Reset</button>
            <p id="contradiction-answer"></p>
          </div>`;
          if (nodeData.contradiction) {
            document.getElementById('contradiction-answer').textContent = `You selected: ${nodeData.contradiction}`;
          }
        }
        detailsContent.innerHTML = html + questionsHtml;
        const radioButtons = document.querySelectorAll('.duplicate-hypotheses input[type="radio"]');
        radioButtons.forEach(rb => {
          rb.addEventListener('change', () => {
            updateDuplicateAnnotationForCurrentNode(nodeData);
          });
        });
        
        // Attach reset event listeners to the dynamically added reset buttons:
        const resetExpButton = detailsContent.querySelector('.reset-experiment');
        if (resetExpButton) {
          resetExpButton.addEventListener('click', () => {
            resetExperimentAnnotationForNode(nodeData);
          });
        }
        const resetContrButton = detailsContent.querySelector('.reset-contradiction');
        if (resetContrButton) {
          resetContrButton.addEventListener('click', () => {
            resetContradictionAnnotationForNode(nodeData);
          });
        }
        
        // Process Structured Hypothesis: Variables and Relationships.
        if (data.structuredHypothesis && data.structuredHypothesis.length > 0) {
          const stHypo = data.structuredHypothesis[0];
          const varTabsContainer = detailsContent.querySelector('.variable-tabs');
          if (varTabsContainer) {
            let variables = stHypo.variables.split(',').map(v => v.trim()).filter(v => v.length > 0);
            const colors = ['#e0f7fa', '#e8f5e9', '#fff3e0', '#f3e5f5', '#e1f5fe'];
            variables.forEach((v, i) => {
              let tab = document.createElement('span');
              tab.textContent = v;
              tab.className = 'variable-tab';
              tab.style.backgroundColor = colors[i % colors.length];
              tab.style.marginRight = "10px";
              tab.style.marginBottom = "10px";
              varTabsContainer.appendChild(tab);
            });
          }
          const relTableBody = detailsContent.querySelector('#relationships-table tbody');
          if (relTableBody) {
            let relLines = stHypo.relationships.split('\n').filter(line => line.trim().length > 0);
            relLines.forEach(line => {
              let cleanedLine = line.replace(/Relationship set \d+:\s*/i, '');
              let regex = /explanatory:\s*([^;]+);\s*response:\s*([^;]+);\s*relationship:\s*(.+)/i;
              let match = cleanedLine.match(regex);
              let tr = document.createElement('tr');
              if (match) {
                let tdExp = document.createElement('td');
                tdExp.textContent = match[1].trim();
                let tdResp = document.createElement('td');
                tdResp.textContent = match[2].trim();
                let tdRel = document.createElement('td');
                tdRel.textContent = match[3].trim();
                tr.appendChild(tdExp);
                tr.appendChild(tdResp);
                tr.appendChild(tdRel);
              } else {
                let td = document.createElement('td');
                td.textContent = cleanedLine;
                td.colSpan = 3;
                tr.appendChild(td);
              }
              relTableBody.appendChild(tr);
            });
          }
        }
        
        const expValidYes = document.getElementById('experiment-valid-yes');
        const expValidNo = document.getElementById('experiment-valid-no');
        const expValidUnsure = document.getElementById('experiment-valid-unsure');
        if (expValidYes && expValidNo && expValidUnsure && !expValidYes.disabled) {
          expValidYes.addEventListener('click', () => {
            nodeData.experimentValid = "Yes";
            document.getElementById('experiment-valid-answer').textContent = "You selected: Yes";
            checkIfAnnotated(nodeData, data);
          });
          expValidNo.addEventListener('click', () => {
            nodeData.experimentValid = "No";
            document.getElementById('experiment-valid-answer').textContent = "You selected: No";
            checkIfAnnotated(nodeData, data);
          });
          expValidUnsure.addEventListener('click', () => {
            nodeData.experimentValid = "Unsure";
            document.getElementById('experiment-valid-answer').textContent = "You selected: Unsure";
            checkIfAnnotated(nodeData, data);
          });
        }
        
        // const contradictionYes = document.getElementById('contradiction-yes');
        // const contradictionNo = document.getElementById('contradiction-no');
        // const contradictionUnsure = document.getElementById('contradiction-unsure');
        // if (contradictionYes && contradictionNo && contradictionUnsure && !contradictionYes.disabled) {
        //   contradictionYes.addEventListener('click', () => {
        //     nodeData.contradiction = "True";
        //     document.getElementById('contradiction-answer').textContent = "You selected: True";
        //     checkIfAnnotated(nodeData, data);
        //   });
        //   contradictionNo.addEventListener('click', () => {
        //     nodeData.contradiction = "False";
        //     document.getElementById('contradiction-answer').textContent = "You selected: False";
        //     checkIfAnnotated(nodeData, data);
        //   });
        //   contradictionUnsure.addEventListener('click', () => {
        //     nodeData.contradiction = "Unsure";
        //     document.getElementById('contradiction-answer').textContent = "You selected: Unsure";
        //     checkIfAnnotated(nodeData, data);
        //   });
        // }
        const contradictionYes = document.getElementById('contradiction-yes');
        const contradictionNo = document.getElementById('contradiction-no');
        const contradictionUnsure = document.getElementById('contradiction-unsure');
        if (contradictionYes && contradictionNo && contradictionUnsure) {
          contradictionYes.addEventListener('click', () => {
            nodeData.contradiction = "True";
            document.getElementById('contradiction-answer').textContent = "You selected: True";
            checkIfAnnotated(nodeData, data);
          });
          contradictionNo.addEventListener('click', () => {
            nodeData.contradiction = "False";
            document.getElementById('contradiction-answer').textContent = "You selected: False";
            checkIfAnnotated(nodeData, data);
          });
          contradictionUnsure.addEventListener('click', (event) => {
            event.stopPropagation();
            nodeData.contradiction = "Unsure";
            document.getElementById('contradiction-answer').textContent = "You selected: Unsure";
            checkIfAnnotated(nodeData, data);
          });
        }
      }
      
      // Full screen toggle for Left Pane
      const leftFullScreenBtn = document.getElementById('left-fullscreen-btn');
      const leftPane = document.getElementById('left-pane');
      const detailsPanel = document.getElementById('details-panel');
      let leftFullScreen = false;
      leftFullScreenBtn.addEventListener('click', () => {
        if (!leftFullScreen) {
          leftPane.style.width = "100%";
          detailsPanel.style.display = "none";
          leftFullScreenBtn.textContent = "Normal";
          leftFullScreen = true;
          // console.log("Left pane set to full screen.");
        } else {
          leftPane.style.width = "50%";
          detailsPanel.style.display = "block";
          leftFullScreenBtn.textContent = "Full Screen";
          leftFullScreen = false;
          // console.log("Left pane set to normal screen.");
        }
        setTimeout(() => {
          if (treeData) renderTree();
        }, 100);
      });
      
      // Full screen toggle for Right Pane
      const rightFullScreenBtn = document.getElementById('right-fullscreen-btn');
      let rightFullScreen = false;
      rightFullScreenBtn.addEventListener('click', () => {
        if (!rightFullScreen) {
          detailsPanel.style.width = "100%";
          leftPane.style.display = "none";
          rightFullScreenBtn.textContent = "Normal";
          rightFullScreen = true;
          // console.log("Right pane set to full screen.");
        } else {
          detailsPanel.style.width = "50%";
          leftPane.style.display = "block";
          rightFullScreenBtn.textContent = "Full Screen";
          rightFullScreen = false;
          // console.log("Right pane set to normal screen.");
        }
      });

      const downloadAllDupBtn = document.getElementById('download-all-duplicate-annotations');
      downloadAllDupBtn.addEventListener('click', () => {
        downloadAllDuplicateAnnotations();
      });
      
      // Download JSON button
      const downloadBtn = document.getElementById('download-json');
      downloadBtn.addEventListener('click', () => {
        if (annotatedNodes.length === 0) {
          alert("No data to download.");
          return;
        }
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(annotatedNodes, null, 2));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "hyp_exp_annotations.json");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
        // console.log("Downloaded JSON.");
      });

      const nextButton = document.getElementById('next-unannotated');
      nextButton.addEventListener('click', () => {
        const next = allNodesFlat.find(n =>
          allowedNodeIDs.has(n.id) &&
          n.id !== (selectedNode && selectedNode.id) &&
          !(n.cluster in answeredClusters)
        );

        if (next) {
          showNodeDetails(next);
          updateClusterHighlights(next.cluster);
        } else {
          alert("All allowed nodes have been annotated!");
        }
      });
      
    }); // End DOMContentLoaded
  </script>
</body>
</html>
