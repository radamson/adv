<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Experiment Tree Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Global styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      font-size: 16px;
      overflow-y: auto;
    }
    details summary {
    font-size: 18px; /* adjust the value as needed */
    font-weight: bold; /* make it bold */}

    details {
    margin-bottom: 2em; /* Adjust the value as needed */
    }

    .container {
      display: flex;
      width: 100%;
    }
    /* Panes */
    #left-pane, #details-panel {
      flex: 1;
      width: 50%;
      box-sizing: border-box;
      transition: width 0.3s, display 0.3s;
    }

    #left-pane {
      display: flex;
      flex-direction: column;
      /* Optionally, set a minimum height if desired */
      min-height: 600px;
    }

    /* Let the tree container expand to fill the left pane */
    #tree-container {
      flex: 1;
      width: 100%;
      height: 100%;
    }

    /* Ensure the overall page allows full height usage */
    html, body {
      height: 100%;
      margin: 0;
    }
    /* #left-pane {
      min-height: 800px;
      border: 1px solid #ccc;
      padding: 10px;
    } */
    #details-panel {
      border: 1px solid #ccc;
      padding: 20px;
      white-space: normal;
    }
    /* Pane headers */
    #left-pane-header, #details-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    /* Tree container */
    /* #tree-container {
      flex: 1;
      border: 1px solid #ccc;
      padding: 10px;
      overflow: auto;
      min-height: 400px;
    } */
    /* Buttons */
    button.yes {
      background-color: green;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button.no {
      background-color: red;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button.unsure {
      background-color: orange;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    button.reset {
      background-color: #757575;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 10px 2px;
      cursor: pointer;
    }
    button.fullscreen-toggle {
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    /* Tree nodes and links (horizontal layout) */
    .node circle {
      fill: steelblue;
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .node text {
      font-size: 10px;
    }
    .node.selected circle {
      fill: #ff5722;
    }
    /* Active cluster highlighting */
    .node.active-cluster circle {
      stroke: #FFFF00;
      stroke-width: 4px;
    }
    /* Deactivated nodes */
    .node.deactivated {
      opacity: 0.3;
    }
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }
    /* Cluster number inside node circle */
    .node-cluster-label {
      pointer-events: none;
      font-size: 8px;
      fill: black;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    /* Upload area */
    .upload-area {
      margin-bottom: 20px;
      padding: 10px;
      border: 2px dashed #ccc;
      text-align: center;
    }
    .file-list {
      display: flex;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .file-item {
      background: #f0f0f0;
      padding: 5px 10px;
      margin: 5px;
      border-radius: 3px;
      font-size: 14px;
    }
    h1, h2, h3, h4 {
      color: #333;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
      overflow: auto;
      max-height: 200px;
      border-radius: 4px;
      white-space: pre-wrap;
    }
    /* Top-right counter */
    .annotated-counter {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: #00796b;
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .counter-tab {
      font-size: 14px;
    }
    .duplicate-hypotheses label {
      margin-right: 10px;
    }
    .highlight-yellow {
      background-color: #FFFF00; /* or any highlight color you prefer */
      /* color: white; */
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-green {
      background-color: green; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-orange {
      background-color: orange; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .highlight-red {
      background-color: red; /* or any highlight color you prefer */
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      /* font-weight: bold; */
    }
    .rubric {
      font-size: 14px;
      font-style: italic;
      margin-top: 0.5em;
      color: #555;
    }
    /* Deduplication Buttons */
    .dup-btn {
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
      color: white;
    }
    .dup-btn[data-answer="Duplicate"] {
      background-color: green;
    }
    .dup-btn[data-answer="Not a duplicate"] {
      background-color: red;
    }
    .dup-btn[data-answer="Unsure"] {
      background-color: orange;
    }
    .dup-reset {
      background-color: grey;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
    /* Visual feedback for selected button */
    .dup-btn.selected-dup {
      outline: 2px solid black;
    }

    /* Download button */
    #download-json {
      margin-top: 10px;
      padding: 10px 15px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    /* Relationships table */
    #relationships-table-container {
      overflow-x: auto;
      word-wrap: break-word;
      white-space: normal;
      margin-bottom: 10px;
    }
    #relationships-table {
      border-collapse: collapse;
      width: 100%;
    }
    #relationships-table th, #relationships-table td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
  </style>
</head>
<body>
  <h1>Experiment Tree Visualization</h1>
  
  <!-- Top counter shows ratio of annotated nodes -->
  <div class="annotated-counter" id="annotated-counter">
    <div id="total-nodes" class="counter-tab">Total number of nodes: 0</div>
    <!-- Note: using "annotation-text" here -->
    <div id="annotation-text">Unique nodes annotated: 0 / 0</div>
    <progress id="annotation-progress" value="0" max="0" style="width: 100%; margin-top: 5px;"></progress>
  </div>

  <!-- Upload area -->
  <div class="upload-area" id="upload-area">
    <p>Drop node log files or a clusters file here or click to upload</p>
    <input type="file" id="file-upload" multiple style="display: none">
    <div class="file-list" id="file-list"></div>
  </div>
  
  <div class="container">
    <!-- Left Pane: Tree Pane -->
    <div id="left-pane">
      <div id="left-pane-header">
        <span>Tree Pane</span>
        <button id="left-fullscreen-btn" class="fullscreen-toggle">Full Screen</button>
      </div>
      <div id="tree-container"></div>
    </div>
    <!-- Right Pane: Details Panel -->
    <div id="details-panel">
      <div id="details-panel-header">
        <span>Node Details</span>
        <button id="right-fullscreen-btn" class="fullscreen-toggle">Full Screen</button>
      </div>
      <div id="details-content">
        <p>Click on a node to view details</p>
      </div>
    </div>
  </div>
  
  <!-- Download button -->
  <!-- <div id="action-bar" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
    <button id="download-json" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Hypothesis and Experiment Annotations
    </button>
    <button id="next-unannotated" style="padding: 10px 15px; background-color: #009688; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Next Unannotated
    </button>
  </div> -->

  <div id="action-bar" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
    <button id="download-json" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Hypothesis/Experiment Annotations
    </button>
    <button id="download-all-duplicate-annotations" style="padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Download Deduplication Annotations
    </button>
    <button id="next-unannotated" style="padding: 10px 15px; background-color: #009688; color: white; border: none; border-radius: 4px; cursor: pointer;">
      Next Unannotated
    </button>
  </div>
  
  
  <script type="module">
    import { getStructuredHypothesis } from './structuredHypothesis.js';
    
    document.addEventListener("DOMContentLoaded", () => {
      // Global variables
      let beliefData = {};
      let treeData = null;
      let selectedNode = null;
      let allNodesFlat = [];
      let annotatedDedups = [];
      let annotatedNodes = [];
      let answeredClusters = {}; // cluster number -> true if answered
      let clusterMapping = {};   // mapping from node id ("0_0") -> cluster number
      let allowedNodeIDs = new Set();
      
      // File processing with debug logging
      function handleFiles(files) {
        // console.log("Handling files:", files);
        fileList.innerHTML = '';
        let filesProcessed = 0;
        Array.from(files).forEach(file => {
          // console.log("Processing file:", file.name);
          if (/subsample_nodes\.json/.test(file.name)) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const subsampleData = JSON.parse(e.target.result);
                subsampleData.forEach(entry => {
                  const id = entry.node_id.replace("node_", "");  // convert "node_3_0" → "3_0"
                  allowedNodeIDs.add(id);
                });
              } catch (err) {
                console.error("Error parsing subsample_nodes.json:", err);
              }
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          }
          else if (/cluster/i.test(file.name)) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const clustersData = JSON.parse(e.target.result);
                for (const clusterKey in clustersData) {
                  clustersData[clusterKey].forEach(item => {
                    let id = item.node_id;
                    if (id.startsWith("node_")) {
                      id = id.slice(5);
                    }
                    clusterMapping[id] = clusterKey;
                    // console.log(`Mapping node id ${id} to cluster ${clusterKey}`);
                  });
                }
              } catch (err) {
                console.error("Error parsing cluster file:", err);
              }
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          } else if (file.name.match(/belief_(\d+)_(\d+)\.json/)) {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.textContent = file.name;
            fileList.appendChild(fileItem);
            const reader = new FileReader();
            reader.onload = (e) => {
              const content = e.target.result;
              parseBeliefFile(file.name, content);
              filesProcessed++;
              if (filesProcessed === files.length) {
                buildTreeFromBeliefs();
              }
            };
            reader.readAsText(file);
          } else {
            filesProcessed++;
            if (filesProcessed === files.length) {
              buildTreeFromBeliefs();
            }
          }
        });
      }
      
      const uploadArea = document.getElementById('upload-area');
      const fileUpload = document.getElementById('file-upload');
      const fileList = document.getElementById('file-list');
      
      uploadArea.addEventListener('click', () => fileUpload.click());
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = '#f0f0f0';
      });
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = 'none';
      });
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.background = 'none';
        // console.log("Drop event:", e.dataTransfer.files);
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          handleFiles(e.dataTransfer.files);
        }
      });
      
      fileUpload.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFiles(e.target.files);
        }
      });
      
      function parseBeliefFile(filename, content) {
        const match = filename.match(/belief_(\d+)_(\d+)\.json/);
        if (!match) return;
        const level = parseInt(match[1]);
        const index = parseInt(match[2]);
        // console.log(`Parsed belief file for level ${level}, index ${index}`);
        try {
          const data = JSON.parse(content);
          if (!beliefData[level]) {
            beliefData[level] = {};
          }
          beliefData[level][index] = data;
        } catch (e) {
          console.error(`Error parsing ${filename}:`, e);
        }
      }
      
      // Instead of one global reset for the node, we define two functions:
      function resetExperimentAnnotationForNode(node) {
        node.experimentValid = null;
        // Remove this node's annotation from the global list
        annotatedNodes = annotatedNodes.filter(a => a.node_id !== node.id);
        if (node.cluster !== undefined) {
          delete answeredClusters[node.cluster];
        }
        showNodeDetails(node);
        updateAnnotatedCounter();
        // console.log(`Experiment annotation for node ${node.id} has been reset.`);
      }
      
      function resetContradictionAnnotationForNode(node) {
        node.contradiction = null;
        annotatedNodes = annotatedNodes.filter(a => a.node_id !== node.id);
        if (node.cluster !== undefined) {
          delete answeredClusters[node.cluster];
        }
        showNodeDetails(node);
        updateAnnotatedCounter();
        // console.log(`Hypothesis Validity ${node.id} has been reset.`);
      }
      
      function buildTreeFromBeliefs() {
        const levels = Object.keys(beliefData).map(Number).sort((a, b) => a - b);
        if (levels.length === 0) return;
        // console.log("Building tree from levels:", levels);
        const root = {
          id: "0_0",
          level: 0,
          index: 0,
          data: getNodeDataFromBelief(beliefData[0][0]),
          children: [],
          isAnnotated: false,
          isDedupAnnotated: false,
        };
        let branchingFactor = 0;
        if (beliefData[1]) {
          branchingFactor = Object.keys(beliefData[1]).length;
        }
        function addChildren(node, level) {
          if (!beliefData[level]) return;
          const indices = Object.keys(beliefData[level]).map(Number).sort((a, b) => a - b);
          indices.forEach(idx => {
            const parentIndex = Math.floor(idx / branchingFactor);
            if (node.level === level - 1 && node.index === parentIndex) {
              const childId = `${level}_${idx}`;
              const childNode = {
                id: childId,
                level: level,
                index: idx,
                data: getNodeDataFromBelief(beliefData[level][idx]),
                children: []
              };
              node.children.push(childNode);
              // console.log(`Adding child ${childId} to node ${node.id}`);
              addChildren(childNode, level + 1);
            }
          });
        }
        for (let i = 1; i < levels.length; i++) {
          addChildren(root, i);
        }
        treeData = root;
        allNodesFlat = [];
        flattenNodes(treeData, allNodesFlat);
        // console.log("Tree built:", treeData);
        const greyNodes = allNodesFlat.filter(n => !n.data.review).map(n => n.id);
        console.log("🟦 Grey nodes (no review):", greyNodes);

        assignClusters(treeData);
        renderTree();
        updateAnnotatedCounter();
      }
      
      function assignClusters(node) {
        if (node && node.id) {
          if (clusterMapping[node.id] !== undefined) {
            node.data.cluster = clusterMapping[node.id];
            node.cluster = clusterMapping[node.id];
            // console.log(`Assigned cluster ${node.cluster} to node ${node.id}`);
          } else {
            console.warn(`No matching cluster for node id: ${node.id}`);
          }
        }
        if (node.children) {
          node.children.forEach(child => assignClusters(child));
        }
      }
      
      function getNodeDataFromBelief(beliefArray) {
        if (!beliefArray) return {};
        const priorBeliefs = beliefArray.filter(b => b.distribution === "prior");
        const posteriorBeliefs = beliefArray.filter(b => b.distribution === "posterior");
        const priorBelief = priorBeliefs[0];
        const posteriorBelief = posteriorBeliefs[0];
        if (!posteriorBelief) return {};
        const messages = posteriorBelief.messages || [];
        let experiment = null;
        let hypothesis = posteriorBelief.current_hypothesis || null;
        let analysis = null;
        let review = null;
        let implementation = null;
        messages.forEach(msg => {
          if (msg.name === "user_proxy") {
            experiment = msg.content;
          } else if (msg.name === "experiment_analyst") {
            try {
              analysis = JSON.parse(msg.content).analysis;
            } catch (e) {
              analysis = msg.content;
            }
          } else if (msg.name === "experiment_reviewer") {
            try {
              const reviewData = JSON.parse(msg.content);
              review = reviewData.feedback;
            } catch (e) {
              review = msg.content;
            }
          } else if (msg.name === "experiment_programmer") {
            try {
              const implementationData = JSON.parse(msg.content);
              console.log(implementationData);
              console.log("======================================================================================================================================");
              implementation = implementationData.code;
              console.log(implementation);
            } catch (e) {
              implementation = msg.content;
            }
          }
        });
        const structuredHypothesis = getStructuredHypothesis(messages);
        return {
          hypothesis,
          experiment,
          analysis,
          review,
          implementation,
          priorSupportsHypothesis: priorBelief ? priorBelief.belief_result?.believes_hypothesis : undefined,
          supportsHypothesis: posteriorBelief ? posteriorBelief.belief_result?.believes_hypothesis : undefined,
          structuredHypothesis: structuredHypothesis
        };
      }
      function renderTree() {
        if (!treeData) return;
        d3.select("#tree-container").selectAll("*").remove();

        const container = document.getElementById('tree-container');
        const width = container.offsetWidth;
        const nodeCount = countNodes(treeData);
        const height = Math.max(container.offsetHeight, nodeCount * 20);


        const margin = { top: 40, right: 90, bottom: 50, left: 90 };

        // Calculate inner dimensions based on the container's size
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const treeLayout = d3.tree().size([innerHeight, innerWidth]);
        const svg = d3.select("#tree-container")
                      .append("svg")
                      .attr("width", width)
                      .attr("height", height)
                      .append("g")
                      .attr("transform", `translate(${margin.left},${margin.top})`);

        const root = d3.hierarchy(treeData);
        const treeDataLayout = treeLayout(root);

        // Render links
        svg.selectAll(".link")
          .data(treeDataLayout.links())
          .enter()
          .append("path")
          .attr("class", "link")
          .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x));

        // Render nodes
        const node = svg.selectAll(".node")
                        .data(treeDataLayout.descendants())
                        .enter()
                        .append("g")
                        .attr("class", d => {
                          let cls = `node node-${d.data.id}`;
                          const isRoot = d.data.id === "0_0";
                          const isAllowed = allowedNodeIDs.has(d.data.id);
                          
                          if (!isRoot) {
                            if (!isAllowed) {
                              cls += " deactivated";
                            } else if (
                              d.data.cluster !== undefined &&
                              answeredClusters[d.data.cluster] &&
                              d.data.id !== (selectedNode && selectedNode.id) &&
                              !d.data.isAnnotated && !d.data.isDedupAnnotated
                            ) {
                              cls += " deactivated";
                            }
                          }

                          return cls;
                        })
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .on("click", (event, d) => {
                          // console.log("Node clicked:", d.data.id, "Cluster:", d.data.cluster);
                          showNodeDetails(d.data);
                          updateClusterHighlights(d.data.cluster);
                        });

        // Example for rendering the node shapes and labels...
        node.append("circle")
            .attr("r", 8)
            .style("fill", d => {
              if (!d.data.data.review) return "#9E9E9E";
              return d.data.data.priorSupportsHypothesis === true ? "#4CAF50" : 
                    d.data.data.priorSupportsHypothesis === false ? "#F44336" : 
                    "#2196F3";
            });

        node.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => d.children ? -12 : 12)
            .attr("text-anchor", d => d.children ? "end" : "start")
            .text(d => `Node_${d.data.level}_${d.data.index}`);

        // Cluster number inside the node
        node.append("text")
            .attr("class", "node-cluster-label")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .text(d => d.data.cluster !== undefined ? d.data.cluster : "N/A");

        node.append("text")
            .attr("x", 0)
            .attr("y", -14)  // positioned above the node
            .attr("text-anchor", "middle")
            .attr("font-size", "14px")
            .attr("fill", "#2E7D32") // green
            .text(d => {
              let annotated = annotatedNodes.some(a => a.node_id === d.data.id);

              // Special case: root node familiarity
              if (d.data.id === "0_0" && treeData.familiarity) {
                annotated = true;
              }

              d.data.isDedupAnnotated = annotated;
              d.data.isAnnotated = annotated;
              return annotated ? "✔" : "";
            });

            d3.select(".node.node-0_0").classed("deactivated", false).classed("active-cluster", false);


      }      
      
        var lastSelectedCluster = null;
        // var answeredClusters = {}; // This should be defined as appropriate elsewhere in your code
        // var selectedNode = {};     // This should contain the current selected node's data
        function updateClusterHighlights(selectedCluster) {

          if (lastSelectedCluster && lastSelectedCluster !== selectedCluster) {
            if (!answeredClusters[lastSelectedCluster]) {
              preservedeactivation(lastSelectedCluster, selectedNode.id);
            } else{
              // console.log("PRESERVE DEACTIVATION...")
              preservedeactivation(lastSelectedCluster, selectedNode.id);
            }

          }

          // For the newly selected cluster, reset nodes only if it is not annotated.
          if (!answeredClusters[selectedCluster]) {
            // Deactivate all nodes in the cluster first
            deactivateOtherNodesInCluster(selectedCluster, null);

            // Then activate only the selected node
            d3.selectAll(".node").each(function(d) {
              if (d.data.cluster === selectedCluster && d.data.id === selectedNode.id && d.data.id !== "0_0") {
                d3.select(this)
                  .classed("active-cluster", true)
                  .classed("deactivated", false);
              }
            });
          }

          // Activate the selected node in the current cluster.
          d3.selectAll(".node").each(function(d) {
            if (d.data.id !== "0_0" && d.data.cluster !== undefined && d.data.cluster === selectedCluster) {
              if (d.data.id === selectedNode.id) {
                d3.select(this)
                  .classed("active-cluster", true)
                  .classed("deactivated", false);
              }
            }
          });

          // Deactivate all other nodes in the current cluster.
          deactivateOtherNodesInCluster(selectedCluster, selectedNode.id);

          // Update the global state with the current cluster.
          lastSelectedCluster = selectedCluster;
        }

        function downloadAllDuplicateAnnotations() {
          // Optionally, update the annotation for the currently visible node before downloading.
          if (selectedNode) {
            updateDuplicateAnnotationForCurrentNode(selectedNode);
          }
          const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(duplicateAnnotationsGlobal, null, 2));
          const downloadAnchor = document.createElement("a");
          downloadAnchor.setAttribute("href", dataStr);
          downloadAnchor.setAttribute("download", "deduplication_annotations.json");
          document.body.appendChild(downloadAnchor);
          downloadAnchor.click();
          downloadAnchor.remove();
        }

        // Helper function 1: Deactivate all nodes in the same cluster except the current node
        function preservedeactivation(cluster, currentNodeId) {
          d3.selectAll(".node").each(function(d) {
            if (d.data.cluster !== undefined && d.data.cluster === cluster) {
              const isAllowed = allowedNodeIDs.has(d.data.id);
              const isSelected = d.data.id === currentNodeId;

              d3.select(this)
                .classed("active-cluster", isSelected)
                .classed("deactivated", !isAllowed); 
            }
          });
        }

        // Helper function 1: Deactivate all nodes in the same cluster except the current node
        function deactivateOtherNodesInCluster(cluster, currentNodeId) {
          d3.selectAll(".node").each(function(d) {
            if (d.data.cluster === cluster && d.data.id !== currentNodeId) {
              const isAllowed = allowedNodeIDs.has(d.data.id);
              d3.select(this)
                .classed("active-cluster", false)
                .classed("deactivated", !isAllowed); // deactivate only if not allowed
            }
          });
        }


        // Helper function 2: Reset activation and deactivation for all nodes in the specified cluster
        function resetClusterNodes(cluster) {
          d3.selectAll(".node").each(function(d) {
            if (d.data.cluster !== undefined && d.data.cluster === cluster) {
              d3.select(this)
                .classed("active-cluster", false)
                .classed("deactivated", false);
            }
          });
        }


      
      function countNodes(node) {
        if (!node) return 0;
        let count = 1;
        if (node.children) {
          node.children.forEach(child => {
            count += countNodes(child);
          });
        }
        return count;
      }

      function flattenNodes(node, list) {
        if (node.id !== "0_0") list.push(node);  // Skip node_0_0
        if (node.children) {
          node.children.forEach(child => flattenNodes(child, list));
        }
      }
      
      function getTotalNodes() {
        return countNodes(treeData);
      }
      
      function updateAnnotatedCounter() {
        const totalAllowed = allowedNodeIDs.size;

        // Count how many allowed nodes are fully annotated
        const fullyAnnotatedCount = allNodesFlat.filter(node =>
          allowedNodeIDs.has(node.id) &&
          node.data.isAnnotated &&
          node.data.isDedupAnnotated
        ).length;

        const totalNodesElem = document.getElementById("total-nodes");
        const annotationTextElem = document.getElementById("annotation-text");
        totalNodesElem.textContent = `Total allowed nodes: ${totalAllowed}`;
        annotationTextElem.textContent = `Unique nodes annotated: ${fullyAnnotatedCount} / ${totalAllowed}`;

        const progressElem = document.getElementById("annotation-progress");
        progressElem.value = fullyAnnotatedCount;
        progressElem.max = totalAllowed;

        // console.log("Updated progress based on allowedNodeIDs");
      }

      
      function saveDuplicateSection(currentNode) {
          const duplicateData = {
            currentHypothesis: currentNode.data.hypothesis,
            duplicateHypotheses: []
          };

          // Find all duplicate hypothesis items.
          const dupItems = document.querySelectorAll(".dup-item");
          dupItems.forEach((item, idx) => {
          // Get the hypothesis text from the <p> element and remove the numbering and "Exact match" label.
          const pElem = item.querySelector("p");
          let hypText = pElem ? pElem.innerText : "";
          hypText = hypText.replace(/^\d+\.\s*/, "").replace(/\s*Exact match\s*/i, "").trim();

          // Get the selected annotation (radio button) for this hypothesis.
          // const selectedRadio = item.querySelector(`input[name="dup-hyp-${idx}"]:checked`);
          // const annotation = selectedRadio ? selectedRadio.value : null;
          const annotation = item.dataset.answer || null;

          // Get the list of node IDs from the <ul> element.
          let nodeIds = [];
          const ulElem = item.querySelector("ul");
          if (ulElem) {
            nodeIds = Array.from(ulElem.querySelectorAll("li")).map(li => li.innerText.trim());
          }

          duplicateData.duplicateHypotheses.push({
            hypothesis: hypText,
            nodeIds: nodeIds,
            annotation: annotation
          });
        });

        // Create and trigger a download for the JSON file.
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(duplicateData, null, 2));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "duplicate_annotations.json");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      }

      function getUniqueHypothesesFromCluster(cluster, currentNodeId) {
        // Filter nodes from the flattened list that are in the same cluster,
        // exclude the current node, and ensure a hypothesis exists.
        const hypotheses = allNodesFlat
          .filter(node => node.cluster === cluster && node.id !== currentNodeId && node.data.hypothesis)
          .map(node => node.data.hypothesis);
          
        // Return only unique hypotheses
        return Array.from(new Set(hypotheses));
      }

      function getNodeIdsForHypothesis(cluster, hypothesis, currentNodeId) {
        return allNodesFlat
          .filter(node => node.cluster === cluster && node.id !== currentNodeId && node.data.hypothesis === hypothesis)
          .map(node => node.id);
      }
      
      function updateDuplicateAnnotationForCurrentNode(currentNode) {
        const duplicateData = {
          currentHypothesis: currentNode.data.hypothesis,
          duplicateHypotheses: []
        };

        // Loop over each duplicate hypothesis item.
        const dupItems = document.querySelectorAll(".dup-item");
        dupItems.forEach((item, idx) => {
          const pElem = item.querySelector("p");
          let hypText = pElem ? pElem.innerText : "";
          // Remove numbering and the "Exact match" text.
          hypText = hypText.replace(/^\d+\.\s*/, "").replace(/\s*Exact match\s*/i, "").trim();

          // Get the selected annotation from the radio button.
          // const selectedRadio = item.querySelector(`input[name="dup-hyp-${idx}"]:checked`);
          // const annotation = selectedRadio ? selectedRadio.value : null;
          const annotation = item.dataset.answer || null;


          // Get the list of node IDs (if any).
          let nodeIds = [];
          const ulElem = item.querySelector("ul");
          if (ulElem) {
            nodeIds = Array.from(ulElem.querySelectorAll("li")).map(li => li.innerText.trim());
          }

          duplicateData.duplicateHypotheses.push({
            hypothesis: hypText,
            nodeIds: nodeIds,
            annotation: annotation
          });
        });
        
        let allSelected;
        // Save/update the global duplicate annotations for this node.
        duplicateAnnotationsGlobal[currentNode.id] = duplicateData;
        
        if (duplicateData.duplicateHypotheses.length === 0) {
          console.log("No duplicate hypotheses found for this node.");
          currentNode.data.isDedupAnnotated = true;
          allSelected = true;
          console.log("All selected:", allSelected);
        } else {
          console.log("Duplicate hypotheses found...");
          // Set the flag to true only if every duplicate hypothesis has a non-null annotation.
          allSelected = duplicateData.duplicateHypotheses.every(item => item.annotation !== null);
          currentNode.data.isDedupAnnotated = allSelected;
          console.log("All selected:", allSelected);
        }

        console.log(`Node ${currentNode.id} dedup annotation complete:`, allSelected);

        // After updating dedup data, update the overall annotated status.
        checkIfAnnotated(currentNode, currentNode.data);
      }

      function checkIfAnnotated(node, data) {
        const reviewExists = data.review && data.review.trim().length > 0;
        // Only mark the node as annotated if:
        // 1. Experiment validity is set, and if a review exists, then a contradiction is also set.
        // 2. And also, the deduplication annotations are complete.
        
        if (node.experimentValid && (reviewExists ? node.contradiction : true) && node.data.isDedupAnnotated) {
          const annotation = {
            node_id: node.id,
            cluster: node.cluster,
            structured_hypothesis: data.structuredHypothesis,
            experiment: data.experiment,
            analysis: data.analysis,
            review: data.review,
            implementation: data.implementation,
            experiment_validity: node.experimentValid,
            hypothesis_verification: node.contradiction,
            implementation_validity: node.implementationValid,
            human_prior: node.humanPrior,
            annotator_familiarity: node.familiarity || null
          };
          if (!annotatedNodes.some(a => a.node_id === node.id)) {
            annotatedNodes.push(annotation);
            console.log("Annotation added for node:", node.id, annotation);
            if (node.cluster !== undefined) {
              answeredClusters[node.cluster] = true;
              console.log("Cluster", node.cluster, "marked as answered.");
            }
          }
          // Mark the node as fully annotated.
          node.data.isAnnotated = true;
          console.log(`IF ---> Node ${node.data.id}: isAnnotated = ${node.data.isAnnotated}, isDedupAnnotated = ${node.data.isDedupAnnotated}`);
        } else {
          // Optionally, you can clear the flag if conditions are not met.
          node.data.isAnnotated = false;
          console.log(`ELSE --> Node ${node.data.id}: isAnnotated = ${node.data.isAnnotated}, isDedupAnnotated = ${node.data.isDedupAnnotated}`);
        }
        updateAnnotatedCounter();
        
        renderTree();
      }


      let duplicateAnnotationsGlobal = {};
      
      function showNodeDetails(nodeData) {
        if (selectedNode && !selectedNode.data.isAnnotated) {
          updateDuplicateAnnotationForCurrentNode(selectedNode);
        }
        selectedNode = nodeData;
        // console.log("Showing details for node:", nodeData.id);
        d3.selectAll(".node").classed("selected", false);
        d3.select(`.node.node-${nodeData.id}`).classed("selected", true);
        const detailsContent = document.getElementById('details-content');
        const data = nodeData.data;
        let html = "";


        if (!nodeData.humanPrior) {
          const priorPrompt = `
            <h3>Human Prior</h3>
            <p><strong>Hypothesis:</strong></p>
            <pre>${data.hypothesis}</pre>
            <p>Before seeing the experiment, do you believe this hypothesis is true?</p>
            <button class="yes" id="prior-true">True</button>
            <button class="no" id="prior-false">False</button>
            <button class="unsure" id="prior-unsure">Unsure</button>
          `;
          detailsContent.innerHTML = priorPrompt;

          document.getElementById("prior-true").onclick = () => {
            nodeData.humanPrior = "True";
            showNodeDetails(nodeData);
          };
          document.getElementById("prior-false").onclick = () => {
            nodeData.humanPrior = "False";
            showNodeDetails(nodeData);
          };
          document.getElementById("prior-unsure").onclick = () => {
            nodeData.humanPrior = "Unsure";
            showNodeDetails(nodeData);
          };
          return;
        }
        
        // Node details header
        html += `<p><strong>Node ID:</strong> ${nodeData.id} | <strong>Cluster:</strong> ${data.cluster !== undefined ? data.cluster : "N/A"}</p>`;
        
        if (data.hypothesis) {
          html += `<h3>Hypothesis</h3><pre>${data.hypothesis}</pre>`;
        }

        const duplicateHypotheses = getUniqueHypothesesFromCluster(nodeData.cluster, nodeData.id);

        if (duplicateHypotheses.length > 0) {
          // const disableRadios = (nodeData.cluster in answeredClusters);
          const disableRadios = (nodeData.cluster in answeredClusters) || (!allowedNodeIDs.has(nodeData.id));
          
          html += `<details open style="margin: 10px 0;">
                    <summary style="color: blue; font-weight: bold;">Evaluate Deduplication Results</summary>
                    <p><i>Are the following hypotheses duplicates of the current hypothesis (see above)?</i></p>
                    <div class="duplicate-hypotheses">`;
                      
          duplicateHypotheses.forEach((hyp, idx) => {
            // Retrieve node IDs for this hypothesis using the helper function
            const matchingNodeIds = getNodeIdsForHypothesis(nodeData.cluster, hyp, nodeData.id);
            html += `<div class="dup-item" style="margin-bottom: 10px;">`;
            // Number the hypothesis and make it bold
            html += `<p>${idx + 1}. ${hyp}`;
            // If the hypothesis exactly matches the current hypothesis, add "Exact match" in green bold.
            if (hyp.trim() === data.hypothesis.trim()) {
              html += ` <span class="highlight-yellow">Exact match</span>`;
            }
            
            html += `<div class="dup-buttons"> 
                      <button type="button" class="dup-btn" data-answer="Duplicate" ${disableRadios ? "disabled" : ""}>Duplicate</button>
                      <button type="button" class="dup-btn" data-answer="Not a duplicate" ${disableRadios ? "disabled" : ""}>Not a duplicate</button>
                      <button type="button" class="dup-btn" data-answer="Unsure" ${disableRadios ? "disabled" : ""}>Unsure</button>
                      <button type="button" class="dup-reset" ${disableRadios ? "disabled" : ""}>Reset</button>
                    </div>`;
            // Expandable section to show node IDs for this hypothesis, expanded by default.
            if (matchingNodeIds.length > 0) {
              html += `<details open style="margin-top: 5px;">
                        <summary style="font-weight: bold;">Show Node IDs</summary>
                        <ul>`;
              matchingNodeIds.forEach(id => {
                html += `<li>${id}</li>`;
              });
              html += `  </ul>
                      </details>`;
            }
            html += `</div>`;
          });
          html += `   </div>
                  </details>`;
          // (Optional: You may still include a save button for the current node if desired.)
        }
    
      
        // Structured Hypothesis Details
        if (data.structuredHypothesis && data.structuredHypothesis.length > 0) {
          const stHypo = data.structuredHypothesis[0];

          html += `<details>
              <summary>Structured Hypothesis Details</summary>
              <h4>Variables</h4>
              <div class="variable-tabs"></div>
              <h4>Relationships</h4>
              <div id="relationships-table-container">
                <table id="relationships-table">
                  <thead>
                    <tr>
                      <th>Explanatory</th>
                      <th>Response</th>
                      <th>Relationship</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
              <h4>Contexts</h4>
              <p>${stHypo.contexts}</p>
            </details>`;
        }

        // Experiment Section
        if (data.experiment) {
          html += `<details open>
                    <summary>Experiment</summary>
                    <pre>${data.experiment}</pre>
                  </details>`;
        }

        // Analysis Section
        if (data.analysis) {
          html += `<details open>
                    <summary>Analysis</summary>
                    <pre>${data.analysis}</pre>
                  </details>`;
        }

        if (nodeData.id === "0_0") {
          const storedFamiliarity = nodeData.familiarity || "";
          html += `
            <div id="familiarity-section" style="margin-bottom: 1.5em;">
              <h3>Annotator Familiarity</h3>
              <p>What is your level of familiarity with this dataset/domain?</p>
              <div class="familiarity-options" style="margin: 0.5em 0;">
                ${[1, 2, 3, 4, 5].map(i => `
                  <label style="margin-right: 1em;">
                    <input type="radio" name="familiarity" value="${i}" ${storedFamiliarity === String(i) ? "checked" : ""}>
                    ${i}
                  </label>
                `).join(" ")}
              </div>
              <p class='rubric'>1 = Not familiar at all, 5 = Very familiar</p>
            </div>
          `;
        }

        // Review Section (collapsed)
        if (data.review) {
          html += `<details>
                    <summary>Review</summary>
                    <pre>${data.review}</pre>
                  </details>`;
        }

        // Implementation Section (new, collapsed)
        // This displays the content coming from "experiment-programmer" if available.
        if (data.implementation) {
          html += `<details>
                    <summary>Implementation</summary>
                    <pre>${data.implementation}</pre>
                  </details>`;
        }
        let questionsHtml = "";
        if (data.experiment) {
          let disableExp = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
          const isAllowed = allowedNodeIDs.has(nodeData.id);
          disableExp = disableExp || !isAllowed;
          questionsHtml += `<div id="exp-questions">
            <h3>Experiment Validity</h3>
            <p>Is the experiment valid?</p>
            <p class='rubric'>Evaluate whether the experiment is valid. Consider if it can be implemented with the available data with little or no modification. Also assess whether the experiment plan effectively contributes to confirming the hypothesis.</p>
            <button id="experiment-valid-yes" class="yes" ${disableExp ? "disabled" : ""}>Yes</button>
            <button id="experiment-valid-no" class="no" ${disableExp ? "disabled" : ""}>No</button>
            <button id="experiment-valid-unsure" class="unsure" ${disableExp ? "disabled" : ""}>Unsure</button>
            <button class="reset-experiment reset">Reset</button>
            <p id="experiment-valid-answer"></p>
          </div>`;
          if (nodeData.experimentValid) {
            document.getElementById('experiment-valid-answer').textContent = `You selected: ${nodeData.experimentValid}`;
          }
        }
        // Determine if the buttons should be disabled (similar to previous questions).
        let disableImpl = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
        const isAllowed = allowedNodeIDs.has(nodeData.id);
        disableImpl = disableImpl || !isAllowed;
        // Append the Implementation Validation question.
        questionsHtml += `<div id="impl-validation-questions">
          <h3>Implementation Validation</h3>
          <p>Was the experiment faithfully implemented?</p>
          <p class='rubric'>Assess whether the experiment was faithfully implemented. The implementation follows the experiment plan without any significant deviations.</p>
          <button id="impl-valid-yes" class="yes" ${disableImpl ? "disabled" : ""}>Yes</button>
          <button id="impl-valid-no" class="no" ${disableImpl ? "disabled" : ""}>No</button>
          <button id="impl-valid-unsure" class="unsure" ${disableImpl ? "disabled" : ""}>Unsure</button>
          <button class="reset-impl reset" ${disableImpl ? "disabled" : ""}>Reset</button>
          <p id="impl-valid-answer"></p>
        </div>`;
        if (nodeData.implementationValid) {
            document.getElementById('impl-validation-questions').textContent = `You selected: ${nodeData.implementationValid}`;
        }
        if (data.review) {
          let disableContr = (nodeData.id === "0_0") || (nodeData.cluster !== undefined && answeredClusters[nodeData.cluster]);
          const isAllowed = allowedNodeIDs.has(nodeData.id);
          disableContr = disableContr || !isAllowed;
          questionsHtml += `<div id="contradiction-questions">
            <h3>Hypothesis Verification</h3>
            <p>Is the hypothesis true or false?</p>
            <p class='rubric'>Indicate whether you believe the hypothesis is true or false based on the experimental evidence presented in the node. If the experimental evidence appears invalid or inconclusive, you may select 'unsure.'</p>
            <button id="contradiction-yes" class="yes" ${disableContr ? "disabled" : ""}>True</button>
            <button id="contradiction-no" class="no" ${disableContr ? "disabled" : ""}>False</button>
            <button id="contradiction-unsure" class="unsure" ${disableContr ? "disabled" : ""}>Unsure</button>
            <button class="reset-contradiction reset">Reset</button>
            <p id="contradiction-answer"></p>
          </div>`;
          if (nodeData.contradiction) {
            document.getElementById('contradiction-answer').textContent = `You selected: ${nodeData.contradiction}`;
          }
        }
        // }
        detailsContent.innerHTML = html + questionsHtml;
      // }
        // Attach click listeners for deduplication answer buttons
        if (nodeData.id === "0_0") {
          const radioButtons = detailsContent.querySelectorAll('input[name="familiarity"]');
          radioButtons.forEach(rb => {
            rb.addEventListener('change', () => {
              nodeData.familiarity = rb.value;
              console.log("📊 Annotator familiarity set to:", nodeData.familiarity);
            });
          });
        }

        const dupButtons = detailsContent.querySelectorAll('.dup-btn');
        dupButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const dupItem = btn.closest('.dup-item');
            if (dupItem) {
              dupItem.dataset.answer = btn.getAttribute('data-answer');
              // Visual feedback: remove any existing 'selected-dup' class and apply it to the clicked button
              const siblingButtons = dupItem.querySelectorAll('.dup-btn');
              siblingButtons.forEach(b => b.classList.remove('selected-dup'));
              btn.classList.add('selected-dup');
            }
            updateDuplicateAnnotationForCurrentNode(nodeData);
          });
        });

        // Attach click listeners for deduplication reset buttons
        const dupResetButtons = detailsContent.querySelectorAll('.dup-reset');
        dupResetButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const dupItem = btn.closest('.dup-item');
            if (dupItem) {
              delete dupItem.dataset.answer;
              const siblingButtons = dupItem.querySelectorAll('.dup-btn');
              siblingButtons.forEach(b => b.classList.remove('selected-dup'));
            }
            updateDuplicateAnnotationForCurrentNode(nodeData);
          });
        });

        // Attach reset event listeners to the dynamically added reset buttons:
        const resetExpButton = detailsContent.querySelector('.reset-experiment');
        if (resetExpButton) {
          resetExpButton.addEventListener('click', () => {
            resetExperimentAnnotationForNode(nodeData);
          });
        }
        const resetContrButton = detailsContent.querySelector('.reset-contradiction');
        if (resetContrButton) {
          resetContrButton.addEventListener('click', () => {
            resetContradictionAnnotationForNode(nodeData);
          });
        }
      // }
        // Process Structured Hypothesis: Variables and Relationships.
        if (data.structuredHypothesis && data.structuredHypothesis.length > 0) {
          const stHypo = data.structuredHypothesis[0];
          const varTabsContainer = detailsContent.querySelector('.variable-tabs');
          if (varTabsContainer) {
            let variables = stHypo.variables.split(',').map(v => v.trim()).filter(v => v.length > 0);
            const colors = ['#e0f7fa', '#e8f5e9', '#fff3e0', '#f3e5f5', '#e1f5fe'];
            variables.forEach((v, i) => {
              let tab = document.createElement('span');
              tab.textContent = v;
              tab.className = 'variable-tab';
              tab.style.backgroundColor = colors[i % colors.length];
              tab.style.marginRight = "10px";
              tab.style.marginBottom = "10px";
              varTabsContainer.appendChild(tab);
            });
          }
          const relTableBody = detailsContent.querySelector('#relationships-table tbody');
          if (relTableBody) {
            let relLines = stHypo.relationships.split('\n').filter(line => line.trim().length > 0);
            relLines.forEach(line => {
              let cleanedLine = line.replace(/Relationship set \d+:\s*/i, '');
              let regex = /explanatory:\s*([^;]+);\s*response:\s*([^;]+);\s*relationship:\s*(.+)/i;
              let match = cleanedLine.match(regex);
              let tr = document.createElement('tr');
              if (match) {
                let tdExp = document.createElement('td');
                tdExp.textContent = match[1].trim();
                let tdResp = document.createElement('td');
                tdResp.textContent = match[2].trim();
                let tdRel = document.createElement('td');
                tdRel.textContent = match[3].trim();
                tr.appendChild(tdExp);
                tr.appendChild(tdResp);
                tr.appendChild(tdRel);
              } else {
                let td = document.createElement('td');
                td.textContent = cleanedLine;
                td.colSpan = 3;
                tr.appendChild(td);
              }
              relTableBody.appendChild(tr);
            });
          }
        }
        
        const expValidYes = document.getElementById('experiment-valid-yes');
        const expValidNo = document.getElementById('experiment-valid-no');
        const expValidUnsure = document.getElementById('experiment-valid-unsure');
        if (expValidYes && expValidNo && expValidUnsure && !expValidYes.disabled) {
          expValidYes.addEventListener('click', () => {
            nodeData.experimentValid = "Yes";
            document.getElementById('experiment-valid-answer').textContent = "You selected: Yes";
            checkIfAnnotated(nodeData, data);
          });
          expValidNo.addEventListener('click', () => {
            nodeData.experimentValid = "No";
            document.getElementById('experiment-valid-answer').textContent = "You selected: No";
            checkIfAnnotated(nodeData, data);
          });
          expValidUnsure.addEventListener('click', () => {
            nodeData.experimentValid = "Unsure";
            document.getElementById('experiment-valid-answer').textContent = "You selected: Unsure";
            checkIfAnnotated(nodeData, data);
          });
        }
        
        const implValidYes = document.getElementById('impl-valid-yes');
        const implValidNo = document.getElementById('impl-valid-no');
        const implValidUnsure = document.getElementById('impl-valid-unsure');
        if (implValidYes && implValidNo && implValidUnsure) {
          implValidYes.addEventListener('click', () => {
            nodeData.implementationValid = "Yes";
            document.getElementById('impl-valid-answer').textContent = "You selected: Yes";
            checkIfAnnotated(nodeData, data);
          });
          implValidNo.addEventListener('click', () => {
            nodeData.implementationValid = "No";
            document.getElementById('impl-valid-answer').textContent = "You selected: No";
            checkIfAnnotated(nodeData, data);
          });
          implValidUnsure.addEventListener('click', () => {
            nodeData.implementationValid = "Unsure";
            document.getElementById('impl-valid-answer').textContent = "You selected: Unsure";
            checkIfAnnotated(nodeData, data);
          });
        }

        // Attach event listener for the reset button for this new question.
        const resetImplButton = detailsContent.querySelector('.reset-impl');
        if (resetImplButton) {
          resetImplButton.addEventListener('click', () => {
            nodeData.implementationValid = null;
            document.getElementById('impl-valid-answer').textContent = "";
            checkIfAnnotated(nodeData, data);
          });
        }

        const contradictionYes = document.getElementById('contradiction-yes');
        const contradictionNo = document.getElementById('contradiction-no');
        const contradictionUnsure = document.getElementById('contradiction-unsure');
        if (contradictionYes && contradictionNo && contradictionUnsure) {
          contradictionYes.addEventListener('click', () => {
            nodeData.contradiction = "True";
            document.getElementById('contradiction-answer').textContent = "You selected: True";
            checkIfAnnotated(nodeData, data);
          });
          contradictionNo.addEventListener('click', () => {
            nodeData.contradiction = "False";
            document.getElementById('contradiction-answer').textContent = "You selected: False";
            checkIfAnnotated(nodeData, data);
          });
          contradictionUnsure.addEventListener('click', (event) => {
            event.stopPropagation();
            nodeData.contradiction = "Unsure";
            document.getElementById('contradiction-answer').textContent = "You selected: Unsure";
            checkIfAnnotated(nodeData, data);
          });
        }
      }
      
      // Full screen toggle for Left Pane
      const leftFullScreenBtn = document.getElementById('left-fullscreen-btn');
      const leftPane = document.getElementById('left-pane');
      const detailsPanel = document.getElementById('details-panel');
      let leftFullScreen = false;
      leftFullScreenBtn.addEventListener('click', () => {
        if (!leftFullScreen) {
          leftPane.style.width = "100%";
          detailsPanel.style.display = "none";
          leftFullScreenBtn.textContent = "Normal";
          leftFullScreen = true;
          // console.log("Left pane set to full screen.");
        } else {
          leftPane.style.width = "50%";
          detailsPanel.style.display = "block";
          leftFullScreenBtn.textContent = "Full Screen";
          leftFullScreen = false;
          // console.log("Left pane set to normal screen.");
        }
        setTimeout(() => {
          if (treeData) renderTree();
        }, 100);
      });
      
      // Full screen toggle for Right Pane
      const rightFullScreenBtn = document.getElementById('right-fullscreen-btn');
      let rightFullScreen = false;
      rightFullScreenBtn.addEventListener('click', () => {
        if (!rightFullScreen) {
          detailsPanel.style.width = "100%";
          leftPane.style.display = "none";
          rightFullScreenBtn.textContent = "Normal";
          rightFullScreen = true;
          // console.log("Right pane set to full screen.");
        } else {
          detailsPanel.style.width = "50%";
          leftPane.style.display = "block";
          rightFullScreenBtn.textContent = "Full Screen";
          rightFullScreen = false;
          // console.log("Right pane set to normal screen.");
        }
      });

      const downloadAllDupBtn = document.getElementById('download-all-duplicate-annotations');
      downloadAllDupBtn.addEventListener('click', () => {
        downloadAllDuplicateAnnotations();
      });
      
      // Download JSON button
      const downloadBtn = document.getElementById('download-json');
      downloadBtn.addEventListener('click', () => {
        if (annotatedNodes.length === 0) {
          alert("No data to download.");
          return;
        }
        let exportData = [...annotatedNodes];
        if (treeData && treeData.id === "0_0" && treeData.familiarity) {
          exportData.unshift({
            node_id: "0_0",
            annotator_familiarity: treeData.familiarity
          });
        }
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "hyp_exp_annotations.json");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
        // console.log("Downloaded JSON.");
      });

      const nextButton = document.getElementById('next-unannotated');
      nextButton.addEventListener('click', () => {
        const next = allNodesFlat.find(n =>
          allowedNodeIDs.has(n.id) &&
          n.id !== (selectedNode && selectedNode.id) &&
          !(n.cluster in answeredClusters)
        );

        if (next) {
          showNodeDetails(next);
          updateClusterHighlights(next.cluster);
        } else {
          alert("All allowed nodes have been annotated!");
        }
      });
      
    }); // End DOMContentLoaded
  </script>
</body>
</html>
